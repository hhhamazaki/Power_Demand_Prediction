<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アンモニア在庫レベル予測ダッシュボード</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: auto;
            color-scheme: dark;
        }
        .container {
            max-width: 1600px;
            width: 100%;
            min-height: 900px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.1);
        }
        .header { text-align: center; margin-bottom: 30px; }
        .title {
            font-size: 2.5rem; font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #00ff88, #ff00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        .control-panel {
            display: grid; grid-template-columns: 1.2fr 1.6fr 0.8fr 0.8fr;
            gap: 20px; margin-bottom: 30px; align-items: stretch;
        }
        .control-group {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px; padding: 20px; text-align: center;
            display: flex; flex-direction: column; /* For vertical alignment */
            transition: background 0.5s, border-color 0.5s;
        }
        .control-group h3 { color: #00ffff; margin-bottom: 15px; font-size: 1.1rem; }
        .refill-level-control {
            display: flex; align-items: center; justify-content: center;
            gap: 10px;
        }
        .btn {
            background: linear-gradient(45deg, #00ffff, #00ff88);
            border: none; color: #000; padding: 8px 15px; border-radius: 5px;
            cursor: pointer; font-weight: bold; transition: all 0.3s ease; font-size: 0.9rem;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4); }
        .input-field {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #e0e0e0; padding: 8px 12px; border-radius: 5px; width: 80px;
            text-align: center; font-size: 1rem;
        }
        .input-field:focus { outline: none; border-color: #00ffff; box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
        .input-field::-webkit-outer-spin-button,
        .input-field::-webkit-inner-spin-button {
            -webkit-appearance: inner-spin-button;
            opacity: 1;
        }
        .date-control { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .date-input {
            background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(0, 255, 255, 0.3);
            color: #e0e0e0; padding: 10px; border-radius: 5px; font-size: 1rem;
        }
        .nav-btn {
            background: linear-gradient(45deg, #ff00ff, #8a2be2);
            border: none; color: white; padding: 8px 12px; border-radius: 5px;
            cursor: pointer; font-weight: bold; transition: all 0.3s ease; font-size: 0.9rem;
        }
        .nav-btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(255, 0, 255, 0.4); }
        
        .date-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 15px;
        }
        .date-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .month-buttons {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            justify-content: center;
        }
        .month-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff; padding: 5px 10px; border-radius: 5px;
            cursor: pointer; transition: all 0.3s ease; font-size: 0.8rem;
        }
        .month-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }
        /* Active (selected) month button: green neon glowing highlight */
        .month-btn.active {
            background: linear-gradient(45deg, #00ff88, #00ffb3);
            color: #002200;
            box-shadow: 0 0 12px rgba(0,255,136,0.9), 0 0 30px rgba(0,255,136,0.6), 0 0 50px rgba(0,255,136,0.25);
            transform: scale(1.06);
            border-color: rgba(0,255,136,0.9);
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
        }

        .month-btn.active:hover {
            box-shadow: 0 0 18px rgba(0,255,136,1), 0 0 40px rgba(0,255,136,0.8), 0 0 70px rgba(0,255,136,0.3);
            transform: scale(1.08);
        }

        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 15px; padding: 20px; margin-bottom: 20px;
            height: 500px; position: relative;
        }
        
        #warningContainer.is-warning {
            background: rgba(255, 0, 255, 0.1);
            border-color: rgba(255, 0, 255, 0.3);
            animation: pulse 2s infinite;
        }
        #warningContainer.is-warning .warning-title {
            color: #ff00ff;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 0, 255, 0.5); }
        }
        .warning-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 10px; transition: color 0.5s; }
        .warning-text { color: #e0e0e0; font-size: 1rem; text-align: left; }

        .stats-panel {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .stat-card {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px; padding: 15px; text-align: center;
        }
        .stat-title { color: #00ffff; font-size: 0.9rem; margin-bottom: 5px; }
        .stat-value { color: #fff; font-size: 1.5rem; font-weight: bold; }
        .loading { text-align: center; color: #00ffff; font-size: 1.2rem; padding: 50px; }
        @media (max-width: 1200px) {
            .container { max-width: 95%; min-height: auto; }
            .control-panel { grid-template-columns: 1fr; gap: 15px; }
            .title { font-size: 2rem; }
        }
        @media (max-width: 768px) {
            .container { padding: 15px; }
            .title { font-size: 1.5rem; }
            .date-input-group { flex-wrap: wrap; }
            .chart-container { height: 400px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">アンモニア在庫レベル予測ダッシュボード（データ連携ライブ版デモ用アプリ）</h1>
        </div>

        <div class="control-panel">
            <div class="control-group" id="warningContainer">
                <h3 class="warning-title" id="warningTitle"></h3>
                <div class="warning-text" id="warningText"></div>
            </div>

            <div class="control-group">
                <h3>基準日選択</h3>
                <div class="date-control">
                    <div class="date-input-group">
                        <button class="nav-btn" onclick="navigateDate(-7)">-7日</button>
                        <button class="nav-btn" onclick="navigateDate(-1)">-1日</button>
                        <div class="date-input-container">
                            <input type="date" id="baseDate" class="date-input" onchange="updateChart()">
                            <div id="baseDateInfo" style="font-size:0.9rem;color:#a0a0a0;margin-top:6px;"></div>
                        </div>
                        <script>
                        // Ensure the date input defaults to Japan-local "today" (JST) when empty.
                        (function(){
                            try {
                                const input = document.getElementById('baseDate');
                                if (!input) return;
                                function jstTodayLocal() {
                                    const now = new Date();
                                    const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
                                    const japanTime = new Date(utc + (9 * 60 * 60000));
                                    // use same ymd format helper defined later in the main script
                                    function localYmd(d){
                                        const y = d.getFullYear();
                                        const m = String(d.getMonth() + 1).padStart(2, '0');
                                        const day = String(d.getDate()).padStart(2, '0');
                                        return `${y}-${m}-${day}`;
                                    }
                                    return localYmd(japanTime);
                                }
                                // Only set when empty to avoid overwriting CSV-driven selection later
                                if (!input.value) {
                                    input.value = jstTodayLocal();
                                }
                            } catch(e) { console.warn('jst default set failed', e); }
                        })();
                        </script>
                        <button class="nav-btn" onclick="navigateDate(1)">+1日</button>
                        <button class="nav-btn" onclick="navigateDate(7)">+7日</button>
                    </div>
                    <div class="month-buttons" id="monthButtons">
                        <!-- 年月ボタンはCSVデータ期間に基づき自動生成 -->
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>補充レベル設定 [m³]</h3>
                <div class="refill-level-control">
                    <button class="btn" onclick="adjustRefillLevel(-10)">-10</button>
                    <input type="number" id="refillLevel" class="input-field" value="600" min="0" max="1000" onchange="updateChart()">
                    <button class="btn" onclick="adjustRefillLevel(10)">+10</button>
                </div>
            </div>

            <div class="control-group">
                <h3>アンサンブル処理</h3>
                <p style="font-size: 0.8rem; color: #a0a0a0; margin-bottom: 10px; text-align: center;">
                    RandomForest + GradientBoosting + Ridge回帰
                </p>
                <div class="refill-level-control" style="flex-direction: column; gap: 15px; justify-content: center; flex-grow: 1;">
                    <button class="btn" onclick="runTrain(event)" style="width: 120px;">学習</button>
                    <button class="btn" onclick="runPredict(event)" style="width: 120px;">予測</button>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-title">基準日の在庫レベル</div>
                <div class="stat-value" id="currentStock">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">予測精度 (R²)</div>
                <div class="stat-value" id="accuracy">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">平均予測誤差</div>
                <div class="stat-value" id="avgError">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">次回補充推奨</div>
                <div class="stat-value" id="nextRefill">-</div>
            </div>
        </div>
    </div>




    <script>
        let chartData = [];
        // Return YYYY-MM-DD for a Date object using its local fields (avoids toISOString() UTC shift).
        function ymd(d) {
            if (!d || !(d instanceof Date) || isNaN(d.getTime())) return '';
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`;
        }

        // Parse various ISO-like strings into a Date that represents the time in JST.
        // For date-only strings (YYYY-MM-DD) this returns JST midnight for that date.
        function parseJstDate(iso) {
            if (!iso) return new Date(NaN);
            // If format is 'YYYY-MM-DD HH:MM:SS' or 'YYYY-MM-DDTHH:MM:SS' without TZ, append +09:00
            if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(iso)) {
                return new Date(iso.replace(' ', 'T') + '+09:00');
            }
            if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/.test(iso)) {
                return new Date(iso + '+09:00');
            }
            // If date-only, assume JST midnight
            if (/^\d{4}-\d{2}-\d{2}$/.test(iso)) {
                return new Date(iso + 'T00:00:00+09:00');
            }
            // Otherwise let Date parse (may include timezone)
            return new Date(iso);
        }

        // Compare date-only (YYYY-MM-DD) strings to avoid time-of-day mismatches
        function isBeforeDateOnly(a, b) {
            // a and b can be Date objects or date-like strings
            const ad = (a instanceof Date) ? a : new Date(a);
            const bd = (b instanceof Date) ? b : new Date(b);
            return ymd(ad) < ymd(bd);
        }
        function isAfterDateOnly(a, b) {
            const ad = (a instanceof Date) ? a : new Date(a);
            const bd = (b instanceof Date) ? b : new Date(b);
            return ymd(ad) > ymd(bd);
        }

        let chart = null;
        let currentRange = 30;


        // CSVファイルの読み込み
        function loadCsvFile() {
            fetch('../data/predictions.csv')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`CSVファイルの読み込みに失敗: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    parseCsvData(csvText);
                })
                .catch(error => {
                    showErrorMessage(error);
                    console.error('CSVファイル読み込みエラー:', error);
                });
        }

        // CSVデータの解析
        function parseCsvData(csvText) {
            if (!csvText) {
                showErrorMessage(new Error('CSVファイルが空です'));
                return;
            }

            const lines = csvText.split('\n').filter(Boolean);
            if (lines.length < 2) {
                showErrorMessage(new Error('CSVにデータが不足しています'));
                return;
            }

            const headers = lines[0].split(',').map(h => h.trim());
            const requiredColumns = ['date', 'actual_ammonia', 'predicted_ammonia'];
            const missing = requiredColumns.filter(c => !headers.includes(c));
            if (missing.length > 0) {
                showErrorMessage(new Error(`必要な列が見つかりません: ${missing.join(', ')}`));
                return;
            }

            chartData = [];
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i];
                if (!row.trim()) continue;
                const values = row.split(',').map(v => v.trim());
                const obj = {};
                headers.forEach((h, idx) => { obj[h] = values[idx] ?? ''; });
                if (obj.date && !isNaN(Date.parse(obj.date))) {
                    chartData.push(obj);
                }
            }

            if (chartData.length === 0) {
                showErrorMessage(new Error('有効なデータが見つかりませんでした'));
                return;
            }

            chartData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // CSVデータ期間に基づく基準値選択ボタンを自動生成
            generateDateButtons();
            
            const middleIndex = Math.floor(chartData.length / 2);
            const baseInput = document.getElementById('baseDate');

            // Robust date -> YYYY-MM-DD normalization.
            // Treat bare timestamps like "YYYY-MM-DD HH:mm:ss" as JST (+09:00)
            function toDateStr(iso) {
                if (!iso) return '';
                // If format is 'YYYY-MM-DD HH:MM:SS', convert to explicit JST offset
                if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(iso)) {
                    const s = iso.replace(' ', 'T') + '+09:00';
                    return ymd(new Date(s));
                }
                // If date-only, assume JST midnight
                if (/^\d{4}-\d{2}-\d{2}$/.test(iso)) {
                    return ymd(new Date(iso + 'T00:00:00+09:00'));
                }
                // Otherwise let Date try to parse (may include timezone)
                try {
                    return ymd(new Date(iso));
                } catch (e) {
                    return '';
                }
            }

            // Default to CSV middle date (normalized) first; only set if the input is still empty
            if (!baseInput.value) {
                baseInput.value = toDateStr(chartData[middleIndex].date);
                // ensure month button highlight updates when baseDate is set by CSV logic
                try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
            }

            updateChart();
            updateSummary();
            updateDataTable();
            
            console.log('CSVデータ読み込み完了:', chartData.length, '行')
            // Prefer Japan-local "today" (JST) as default base date when possible.
            // Use normalized YYYY-MM-DD strings for all comparisons to avoid
            // timezone parsing differences between browsers.
            (function(){
                // Compute "today" in Japan Standard Time explicitly to avoid browser TZ issues.
                function jstTodayString(){
                    const now = new Date();
                    const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
                    const japanTime = new Date(utc + (9 * 60 * 60000));
                    return ymd(japanTime);
                }

                const todayStr = jstTodayString();
                const initialBaseEmpty = !baseInput.value;

                const normalizedDates = chartData.map(d => toDateStr(d.date)).filter(Boolean).sort();
                console.debug('parseCsvData:', { todayStr, normalizedDatesSample: normalizedDates.slice(-6), chartLen: chartData.length, initialBaseEmpty });
                if (normalizedDates.length === 0) {
                    if (initialBaseEmpty) baseInput.value = '';
                    return;
                }

                // 1) If CSV explicitly contains today's JST date, use it.
                // 1) If CSV explicitly contains today's JST date, use it.
                if (normalizedDates.includes(todayStr)) {
                    if (initialBaseEmpty) {
                        baseInput.value = todayStr;
                        console.debug('parseCsvData: set todayStr ->', baseInput.value);
                        try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                    } else {
                        console.debug('parseCsvData: todayStr in range but input already set ->', baseInput.value);
                    }
                    return;
                }

                // 2) If today (JST) falls within the CSV range (string comparison works for YYYY-MM-DD), use it.
                const first = normalizedDates[0];
                const last = normalizedDates[normalizedDates.length - 1];
                if (todayStr >= first && todayStr <= last) {
                    if (initialBaseEmpty) {
                        baseInput.value = todayStr;
                        console.debug('parseCsvData: set todayStr (within range) ->', baseInput.value);
                        try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                    } else {
                        console.debug('parseCsvData: todayStr within range but input already set ->', baseInput.value);
                    }
                    return;
                }

                // 3) Prefer the latest past date <= todayStr.
                const past = normalizedDates.filter(d => d <= todayStr);
                if (past.length > 0) {
                    if (initialBaseEmpty) {
                        baseInput.value = past[past.length - 1];
                        console.debug('parseCsvData: set latest past ->', baseInput.value);
                            try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                    } else {
                        console.debug('parseCsvData: would set latest past but input already set ->', baseInput.value);
                    }
                    return;
                }

                // 4) Fallback to middle date (or first if something is odd).
                if (initialBaseEmpty) {
                    baseInput.value = normalizedDates[Math.floor(normalizedDates.length / 2)] || first;
                    console.debug('parseCsvData: fallback ->', baseInput.value);
                    try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                } else {
                    console.debug('parseCsvData: fallback (no change, input already set) ->', baseInput.value);
                }
            })();

            updateChart();
        }

        // Try to load external CSV from data/predictions.csv; if fails, fall back to embedded CSV
        async function loadCsvFromDataFile() {
            const dataPath = '../data/predictions.csv';
            try {
                const res = await fetch(dataPath, { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const csvText = (await res.text()).replace(/\r\n/g, '\n').trim();
                if (!csvText) throw new Error('Empty CSV');

                // parse same as embedded loader
                const lines = csvText.split('\n').filter(Boolean);
                if (lines.length < 2) throw new Error('CSV has insufficient rows');
                const headers = lines[0].split(',').map(h => h.trim());
                const requiredColumns = ['date', 'actual_ammonia', 'predicted_ammonia'];
                const missing = requiredColumns.filter(c => !headers.includes(c));
                if (missing.length > 0) throw new Error(`Missing columns: ${missing.join(',')}`);

                chartData = [];
                for (let i = 1; i < lines.length; i++) {
                    const row = lines[i];
                    if (!row.trim()) continue;
                    const values = row.split(',').map(v => v.trim());
                    const obj = {};
                    headers.forEach((h, idx) => { obj[h] = values[idx] ?? ''; });
                    if (obj.date && !isNaN(Date.parse(obj.date))) {
                        chartData.push(obj);
                    }
                }

                if (chartData.length === 0) throw new Error('No valid data in CSV');

                chartData.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                // CSVデータ期間に基づく基準値選択ボタンを自動生成
                generateDateButtons();
                
                // Prefer Japan-local "today" (JST) as default base date when possible.
                // Define a local toDateStr to ensure consistent normalization.
                function toDateStr_local(iso) {
                    if (!iso) return '';
                    if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(iso)) {
                        return ymd(new Date(iso.replace(' ', 'T') + '+09:00'));
                    }
                    if (/^\d{4}-\d{2}-\d{2}$/.test(iso)) {
                        return ymd(new Date(iso + 'T00:00:00+09:00'));
                    }
                    try { return ymd(new Date(iso)); } catch(e) { return ''; }
                }

                const now = new Date();
                const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
                const japanTime = new Date(utc + (9 * 60 * 60000));
                const todayStr = ymd(japanTime);
                const baseInput = document.getElementById('baseDate');
                const initialBaseEmpty = !baseInput.value;

                const normalizedDates = chartData.map(d => toDateStr_local(d.date)).filter(Boolean).sort();
                console.debug('loadCsvFromDataFile:', { todayStr, normalizedDatesSample: normalizedDates.slice(-6), chartLen: chartData.length, initialBaseEmpty });
                if (normalizedDates.length === 0) {
                    if (initialBaseEmpty) baseInput.value = '';
                    console.debug('loadCsvFromDataFile: no normalized dates');
                } else if (normalizedDates.includes(todayStr)) {
                    if (initialBaseEmpty) {
                        baseInput.value = todayStr;
                        console.debug('loadCsvFromDataFile: set todayStr ->', baseInput.value);
                        try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                    } else {
                        console.debug('loadCsvFromDataFile: todayStr contained but input already set ->', baseInput.value);
                    }
                } else {
                    const first = normalizedDates[0];
                    const last = normalizedDates[normalizedDates.length - 1];
                    if (todayStr >= first && todayStr <= last) {
                        if (initialBaseEmpty) {
                            baseInput.value = todayStr;
                            console.debug('loadCsvFromDataFile: set todayStr (within range) ->', baseInput.value);
                            try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                        } else {
                            console.debug('loadCsvFromDataFile: todayStr within range but input already set ->', baseInput.value);
                        }
                    } else {
                        const past = normalizedDates.filter(d => d <= todayStr);
                        if (past.length > 0) {
                            if (initialBaseEmpty) {
                                baseInput.value = past[past.length - 1];
                                console.debug('loadCsvFromDataFile: set latest past ->', baseInput.value);
                                    try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                            } else {
                                console.debug('loadCsvFromDataFile: would set latest past but input already set ->', baseInput.value);
                            }
                        } else {
                            if (initialBaseEmpty) {
                                baseInput.value = normalizedDates[Math.floor(normalizedDates.length / 2)] || first;
                                console.debug('loadCsvFromDataFile: fallback ->', baseInput.value);
                                    try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
                            } else {
                                console.debug('loadCsvFromDataFile: fallback (no change, input already set) ->', baseInput.value);
                            }
                        }
                    }
                }

                updateChart();
            } catch (err) {
                // Fall back to embedded CSV
                loadCsvFile();
            }
        }

        // CSVデータ期間に基づく基準値選択ボタンを自動生成
        function generateDateButtons() {
            if (chartData.length === 0) return;
            
            const monthButtons = document.getElementById('monthButtons');
            if (!monthButtons) return;
            
            // 月単位でグループ化
            const months = new Set();
            chartData.forEach(item => {
                const date = parseJstDate(item.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.add(monthKey);
            });
            
            // ボタンを生成
            monthButtons.innerHTML = '';
            Array.from(months).sort().forEach(monthKey => {
                const [year, month] = monthKey.split('-');
                const shortYear = year.slice(-2);
                const button = document.createElement('button');
                button.className = 'month-btn';
                button.textContent = `${shortYear}/${month}`;
                button.dataset.monthKey = monthKey;
                // Use centralized syncing: call setBaseDate then updateActiveMonthButton()
                button.onclick = () => {
                    setBaseDate(`${year}-${month}-01`);
                    try { updateActiveMonthButton(); } catch (e) { /* ignore */ }
                };
                monthButtons.appendChild(button);
            });

            // Initialize active button to match current baseDate if possible
            try {
                const baseInput = document.getElementById('baseDate');
                if (baseInput && baseInput.value) {
                    const d = parseJstDate(baseInput.value);
                    const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
                    const btn = Array.from(monthButtons.children).find(b => b.dataset.monthKey === key);
                    if (btn) {
                        Array.from(monthButtons.children).forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                }
            } catch (e) { /* ignore initialization errors */ }
        }

        // Update the month button active state to match the current baseDate input
        function updateActiveMonthButton() {
            const baseInput = document.getElementById('baseDate');
            if (!baseInput || !baseInput.value) return;
            const monthButtons = document.getElementById('monthButtons');
            if (!monthButtons) return;
            try {
                const d = parseJstDate(baseInput.value);
                const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
                Array.from(monthButtons.children).forEach(b => b.classList.toggle('active', b.dataset.monthKey === key));
            } catch(e) {
                // ignore
            }
        }

        function showErrorMessage(error) {
            const errorHtml = `
                <div class="loading" style="text-align: left; padding: 30px;">
                    <h3 style="color: #ff00ff; margin-bottom: 20px;">⚠️ データ読み込みエラー</h3>
                    <p style="color: #e0e0e0; margin-bottom: 15px;"><strong>エラー詳細:</strong> ${error.message}</p>
                    <div style="color: #a0a0a0; font-size: 0.9rem;">
                        <p><strong>確認事項:</strong></p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>predictions.csvファイルが存在し、正しい形式であるか</li>
                            <li>ヘッダーが「date, actual_power, actual_ammonia, is_refill, predicted_ammonia, prediction_error, prediction_error_pct」になっているか</li>
                        </ul>
                    </div>
                </div>
            `;
            document.querySelector('.chart-container').innerHTML = errorHtml;
        }

        // 補充レベル調整
        function adjustRefillLevel(amount) {
            const input = document.getElementById('refillLevel');
            const newValue = parseInt(input.value, 10) + amount;
            if (newValue >= 0 && newValue <= 1000) {
                input.value = String(newValue);
                updateChart();
            }
        }

        // 日付ナビゲーション
        function navigateDate(days) {
            const dateInput = document.getElementById('baseDate');
            const currentDate = new Date(dateInput.value);
            currentDate.setDate(currentDate.getDate() + days);
            dateInput.value = ymd(currentDate);
            updateChart();
        }

        function setBaseDate(dateStr) {
            const dateInput = document.getElementById('baseDate');
            dateInput.value = dateStr;
            updateChart();
            // Sync active month button
            try {
                const monthButtons = document.getElementById('monthButtons');
                if (!monthButtons) return;
                const d = parseJstDate(dateStr);
                const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
                Array.from(monthButtons.children).forEach(b => b.classList.toggle('active', b.dataset.monthKey === key));
            } catch (e) {
                // ignore
            }
        }

        // チャート更新
        function updateChart() {
            if (chartData.length === 0) {
                return;
            }

            const baseDateStr = document.getElementById('baseDate').value;
            if (!baseDateStr) {
                return;
            }
            // parsed date from user input (may be outside data range)
            // Use parseJstDate to treat date-only inputs as JST midnight and avoid UTC shift issues
            const userBaseDate = parseJstDate(baseDateStr);

            const minDate = new Date('2024-10-01');
            // Determine maxDate from the last row in the loaded chartData (assumes chartData is sorted ascending)
            const maxDate = parseJstDate(chartData[chartData.length - 1].date);

            // Prepare info box
            const baseDateInfo = document.getElementById('baseDateInfo');
            if (baseDateInfo) baseDateInfo.textContent = '';

            // Clamp internally: do NOT overwrite the input.value, but use clamped date for rendering
            let baseDate = userBaseDate;
            if (isNaN(baseDate.getTime())) return;
            const dateInput = document.getElementById('baseDate');
            if (isBeforeDateOnly(baseDate, minDate)) {
                baseDate = minDate;
                if (dateInput) dateInput.value = ymd(baseDate);
                if (baseDateInfo) baseDateInfo.textContent = `注意: 入力日はデータ範囲より前です。表示は ${ymd(baseDate)} にクランプしています。`;
            } else if (isAfterDateOnly(baseDate, maxDate)) {
                // clamp and update the input so user sees the clamped date (align with standalone behavior)
                baseDate = maxDate;
                if (dateInput) dateInput.value = ymd(baseDate);
                if (baseDateInfo) baseDateInfo.textContent = `注意: 入力日はデータ範囲を超えています。表示は最終データ日 ${ymd(baseDate)} にクランプしています。`;
                // also set visual warning similar to standalone
                const warningContainer = document.getElementById('warningContainer');
                const warningTitle = document.getElementById('warningTitle');
                const warningText = document.getElementById('warningText');
                if (warningTitle && warningText && warningContainer) {
                    warningTitle.innerHTML = '⚠️ 入力日がデータ範囲を超えています';
                    warningText.innerHTML = `入力日はデータの最終日 (${ymd(baseDate)}) を超えています。表示は最終データ日へクランプされています。`;
                    warningContainer.classList.add('is-warning');
                }
            }

            const refillLevel = parseInt(document.getElementById('refillLevel').value, 10);

            const startDate = new Date(baseDate);
            startDate.setDate(startDate.getDate() - currentRange);
            const endDate = new Date(baseDate);
            endDate.setDate(endDate.getDate() + currentRange);

            const filteredData = chartData.filter(item => {
                const d = parseJstDate(item.date);
                return d >= startDate && d <= endDate;
            });

            if (filteredData.length === 0) {
                if (chart) chart.destroy();
                const ctx = document.getElementById('mainChart').getContext('2d');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                return;
            }

            const labels = filteredData.map(item => {
                const d = parseJstDate(item.date);
                return `${d.getMonth() + 1}/${d.getDate()}`;
            });
            const actualAmmoniaData = filteredData.map(item => {
                const val = parseFloat(item.actual_ammonia);
                return (!isNaN(val) && item.actual_ammonia !== '') ? val : null;
            });
            const predictedAmmoniaData = filteredData.map(item => parseFloat(item.predicted_ammonia) || 0);
            const actualPowerData = filteredData.map(item => parseFloat(item.actual_power) || 0);
            const refillLevelData = new Array(labels.length).fill(refillLevel);

            if (chart) chart.destroy();
            const ctx = document.getElementById('mainChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: '実績在庫 (m³)', data: actualAmmoniaData, borderColor: '#00ffff', backgroundColor: 'rgba(0, 255, 255, 0.1)', borderWidth: 3, tension: 0.4, yAxisID: 'y', spanGaps: false },
                        { label: '予測在庫 (m³)', data: predictedAmmoniaData, borderColor: '#00ff88', backgroundColor: 'rgba(0, 255, 136, 0.1)', borderWidth: 2, borderDash: [5,5], tension: 0.4, yAxisID: 'y', pointRadius: 0 },
                        { label: '補充レベル (m³)', data: refillLevelData, borderColor: '#ff00ff', backgroundColor: 'rgba(255, 0, 255, 0.1)', borderWidth: 2, borderDash: [10,5], tension: 0, yAxisID: 'y', pointRadius: 0 },
                        { label: '発電実績 (kW)', data: actualPowerData, borderColor: '#ffaa00', backgroundColor: 'rgba(255,170,0,0.1)', borderWidth: 1, tension: 0.4, yAxisID: 'y1' }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { labels: { color: '#e0e0e0', font: { size: 12 } } },
                        tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#00ffff', bodyColor: '#e0e0e0', borderColor: '#00ffff', borderWidth: 1 }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(0,255,255,0.1)' },
                            ticks: {
                                color: (context) => {
                                    const baseDateLabel = `${baseDate.getMonth() + 1}/${baseDate.getDate()}`;
                                    const currentLabel = context.chart.data.labels[context.index];
                                    return currentLabel === baseDateLabel ? 'red' : '#e0e0e0';
                                },
                                callback: function(value, index, ticks) {
                                    const label = this.getLabelForValue(value);
                                    const baseDateLabel = `${baseDate.getMonth() + 1}/${baseDate.getDate()}`;
                                    if (label === baseDateLabel) {
                                        return ['基準日', label];
                                    }
                                    return label;
                                }
                            }
                        },
                        y: { type: 'linear', display: true, position: 'left', title: { display: true, text: '在庫レベル (m³)', color: '#00ffff' }, grid: { drawOnChartArea: false }, ticks: { color: '#e0e0e0' } },
                        y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: '発電量 (kW)', color: '#ffaa00' }, grid: { drawOnChartArea: false }, ticks: { color: '#e0e0e0' } }
                    }
                },
                plugins: [{
                    id: 'baseDateLine',
                    afterDraw: (chart) => {
                        const baseDateLabel = `${baseDate.getMonth() + 1}/${baseDate.getDate()}`;
                        const index = chart.data.labels.indexOf(baseDateLabel);
                        if (index === -1) return;

                        const ctx = chart.ctx;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const x = xAxis.getPixelForValue(index);

                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }]
            });

            checkRefillWarning(filteredData, refillLevel, baseDate);
            updateStats(filteredData, baseDate);
        }

        // 補充警告
        function checkRefillWarning(data, refillLevel, baseDate) {
            const warningContainer = document.getElementById('warningContainer');
            const warningTitle = document.getElementById('warningTitle');
            const warningText = document.getElementById('warningText');
            const futureData = data.filter(item => parseJstDate(item.date) >= baseDate);
            const warningDays = [];

            for (const item of futureData) {
                const predictedLevel = parseFloat(item.predicted_ammonia) || 0;
                if (predictedLevel < refillLevel) {
                    const daysFromBase = Math.ceil((parseJstDate(item.date) - baseDate) / (1000*60*60*24));
                    warningDays.push({ days: daysFromBase, level: predictedLevel, date: item.date });
                }
            }

            if (warningDays.length > 0) {
                const nearestWarning = warningDays[0];
                warningTitle.innerHTML = `⚠️ 補充警告`;
                warningText.innerHTML = `
                    ${nearestWarning.days}日後（${nearestWarning.date}）に在庫レベルが補充レベル（${refillLevel} m³）を下回る予測です。<br>
                    予測在庫レベル: ${nearestWarning.level.toFixed(1)} m³
                `;
                warningContainer.classList.add('is-warning');
            } else {
                warningTitle.innerHTML = `✅ 警告なし`;
                warningText.innerHTML = '予測期間内に補充レベルを下回る予測はありません。';
                warningContainer.classList.remove('is-warning');
            }
        }

        // 統計
        function updateStats(data, baseDate) {
            if (data.length === 0) return;
            // 日付部分のみで比較（タイムスタンプを含む日付が一致しない問題対策）
            const baseDateStr = ymd(baseDate);
            const baseData = data.find(item => {
                const itemDateStr = ymd(new Date(item.date));
                return itemDateStr === baseDateStr;
            });
            const currentStock = baseData ? parseFloat(baseData.actual_ammonia) : NaN;
            if (!isNaN(currentStock)) {
                document.getElementById('currentStock').textContent = `${currentStock.toFixed(1)} m³`;
            } else {
                document.getElementById('currentStock').textContent = 'データ無し';
            }

            const actualValues = data.map(item => parseFloat(item.actual_ammonia) || 0);
            const predictedValues = data.map(item => parseFloat(item.predicted_ammonia) || 0);
            const r2 = calculateR2(actualValues, predictedValues);
            document.getElementById('accuracy').textContent = `${(r2 * 100).toFixed(1)}%`;

            const errors = data.map(item => Math.abs(parseFloat(item.prediction_error) || 0));
            const avgError = errors.reduce((s, e) => s + e, 0) / errors.length;
            document.getElementById('avgError').textContent = `${avgError.toFixed(1)} m³`;

            // 次回補充推奨（予測値ベース）
            const refillLevel = parseInt(document.getElementById('refillLevel').value, 10);
            const futureData = data.filter(item => parseJstDate(item.date) > baseDate);
            
            if (futureData.length > 0) {
                // 予測値が補充レベルを下回る最初の日を検索
                const nextRefillPrediction = futureData.find(item => 
                    parseFloat(item.predicted_ammonia) <= refillLevel
                );
                
                if (nextRefillPrediction) {
                    const nextRefillDate = new Date(nextRefillPrediction.date);
                    const daysUntilRefill = Math.ceil((nextRefillDate - baseDate) / (1000 * 60 * 60 * 24));
                    const formattedDate = nextRefillDate.toLocaleDateString('ja-JP', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });
                    document.getElementById('nextRefill').textContent = `${formattedDate}（${daysUntilRefill}日後）`;
                } else {
                    // is_refillフラグによる補充予定を確認
                    const futureRefills = futureData.filter(item =>
                        parseInt(item.is_refill, 10) === 1
                    );
                    if (futureRefills.length > 0) {
                        const nextRefillDate = new Date(futureRefills[0].date);
                        const daysUntilRefill = Math.ceil((nextRefillDate - baseDate) / (1000 * 60 * 60 * 24));
                        const formattedDate = nextRefillDate.toLocaleDateString('ja-JP', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit'
                        });
                        document.getElementById('nextRefill').textContent = `${formattedDate}（${daysUntilRefill}日後）`;
                    } else {
                        document.getElementById('nextRefill').textContent = '予測期間内になし';
                    }
                }
            } else {
                document.getElementById('nextRefill').textContent = '予測データなし';
            }
        }

        function calculateR2(actual, predicted) {
            if (actual.length !== predicted.length || actual.length === 0) return 0;
            const mean = actual.reduce((s, v) => s + v, 0) / actual.length;
            const ssTot = actual.reduce((s, v) => s + Math.pow(v - mean, 2), 0);
            const ssRes = actual.reduce((s, v, i) => s + Math.pow(v - predicted[i], 2), 0);
            return ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
        }

        async function runProcess(endpoint, processName, button) {
            const originalText = button.textContent;
            button.textContent = '実行中...';
            button.disabled = true;

            try {
                // Use a same-origin relative path to avoid relying on window.location.origin
                // which can be undefined or point to the wrong port in some cases.
                const response = await fetch(`/${endpoint}`, {
                    method: 'POST',
                });

                const result = await response.json();

                if (response.ok) {
                    alert(`'${processName}' が完了しました。ページをリロードして結果を確認してください。

サーバー出力:
${result.output}`);
                } else {
                    alert(`'${processName}' でエラーが発生しました。

エラー:
${result.output || result.message}`);
                }
            } catch (error) {
                alert(`サーバーとの通信に失敗しました。ローカルサーバーが起動していることを確認してください。

${error}`);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        function runTrain(event) {
            runProcess('run-train', '学習', event.target);
        }

        function runPredict(event) {
            runProcess('run-predict', '予測', event.target);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Try to load external CSV first; fall back to embedded CSV if unavailable
            loadCsvFromDataFile().then(() => {
                try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
            }).catch(() => {
                try { updateActiveMonthButton(); } catch(e) { /* ignore */ }
            });
        });
    </script>
</body>
</html>