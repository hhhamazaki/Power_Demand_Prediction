<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>電力需要AI予測ダッシュボード</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Pyodide for running Python in browser -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%); color: #e0e0e0; min-height: 100vh; overflow-x: auto; color-scheme: dark; }
        .container { max-width: 1600px; width:100%; min-height: 700px; margin: 0 auto; padding: 20px; background: rgba(0,0,0,0.3); backdrop-filter: blur(10px); border-radius: 15px; box-shadow: 0 8px 32px rgba(0,255,255,0.1); }
    .header { text-align: center; margin-bottom: 30px; }
    .title { font-size: 2.6rem; font-weight: bold; text-align: center; margin-bottom: 18px; background: linear-gradient(45deg, #00ffff, #00ff88, #ff00ff); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; text-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
    /* 4カードを均等幅にする */
    .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
        
        
        .card { background: rgba(0,255,255,0.03); border: 1px solid rgba(0,255,255,0.12); border-radius: 10px; padding: 16px; }
    .card h3 { color: #00ffff; margin-bottom: 12px; font-size: 1.1rem; }
    .btn { background: linear-gradient(45deg,#00ffff,#00ff88); border: none; padding: 8px 12px; border-radius:6px; cursor:pointer; color:#000; font-weight:bold }
        .btn.primary.active { box-shadow: 0 0 18px rgba(0,255,136,0.9); background: linear-gradient(45deg,#00ff88,#00ffb3); color:#002200 }
        /* 未選択かつ実行中でないボタンを反転表示（視覚的に目立たせる） */
        /* 未選択かつ実行中でないボタンを反転表示 (全ボタン対象) */
            .btn:not(.active):not(.running) {
                background: linear-gradient(45deg, rgba(0,255,136,0.28), rgba(0,255,136,0.12));
                color: #00ff88; /* 反転時の文字色を緑基調に合わせる */
                border: 1px solid rgba(0,255,136,0.75); /* 枠線をやや濃く */
                box-shadow: 0 0 12px rgba(0,255,136,0.32), inset 0 0 10px rgba(0,255,136,0.08);
                transform: none;
            }
        
        /* JS が付ける inverted クラス用（互換） */
            /* .btn.inverted: JSから付与する互換クラス（緑ネオン） */
            .btn.inverted {
                background: linear-gradient(45deg, rgba(0,255,136,0.28), rgba(0,255,136,0.12));
                color: #00ff88; /* 反転時の文字色を緑基調に合わせる */
                border: 1px solid rgba(0,255,136,0.85); /* 枠線をやや濃く */
                box-shadow: 0 0 12px rgba(0,255,136,0.32), inset 0 0 10px rgba(0,255,136,0.08);
            }
        /* 実行中はマゼンタ/ピンク系ネオンで強調 */
        .btn.running {
            box-shadow: 0 0 18px rgba(0,255,136,0.9), 0 0 40px rgba(0,255,136,0.4);
            background: linear-gradient(45deg,#00ff88,#00ffb3);
            color: #002200;
            transform: scale(1.04);
            border-color: rgba(0,255,136,0.9);
        }
        /* 特定の実行系ボタンをマゼンタ基調にする（処理/学習/取得/予測/組み合わせ検証） */
        #dataProcessBtn, #trainBtn, #getLatestBtn, #predictBtn, #optimizeYearsBtn {
            background: linear-gradient(45deg,#ff00ff,#ff88ff);
            color: #fff;
            border: none;
            box-shadow: 0 0 8px rgba(255,0,255,0.18);
        }
        /* これら特定ボタンの反転（未選択・未実行）時は淡いマゼンタ背景にする。一般の緑反転より優先される */
        #dataProcessBtn:not(.active):not(.running), #trainBtn:not(.active):not(.running), #getLatestBtn:not(.active):not(.running), #predictBtn:not(.active):not(.running), #optimizeYearsBtn:not(.active):not(.running) {
            /* 緑反転と同等の濃さに調整 */
            background: linear-gradient(45deg, rgba(255,0,255,0.28), rgba(255,0,255,0.12));
            color: #ff66ff; /* 反転時はマゼンタ系テキスト */
            border: 1px solid rgba(255,0,255,0.75);
            box-shadow: 0 0 12px rgba(255,0,255,0.32), inset 0 0 10px rgba(255,0,255,0.08);
        }
        /* JS で .inverted クラスがつく場合の上書き（互換） */
        #dataProcessBtn.inverted, #trainBtn.inverted, #getLatestBtn.inverted, #predictBtn.inverted, #optimizeYearsBtn.inverted {
            background: linear-gradient(45deg, rgba(255,0,255,0.28), rgba(255,0,255,0.12)) !important;
            color: #ff66ff !important; /* JS 互換時の文字色 */
            border: 1px solid rgba(255,0,255,0.75) !important;
            box-shadow: 0 0 12px rgba(255,0,255,0.32) !important;
        }
        /* デフォルト（実行中でない）状態は反転で濃めのマゼンタに調整 */
        #dataProcessBtn:not(.running), #trainBtn:not(.running), #getLatestBtn:not(.running), #predictBtn:not(.running), #optimizeYearsBtn:not(.running) {
            background: linear-gradient(45deg, rgba(255,0,255,0.28), rgba(255,0,255,0.12));
            color: #ff66ff;
            border: 1px solid rgba(255,0,255,0.75);
            box-shadow: 0 0 12px rgba(255,0,255,0.32), inset 0 0 10px rgba(255,0,255,0.08);
        }
        /* Fine-grained running styles:
           - 最新データ取得・データ処理: 実行中でも縮小/拡大しない
           - 学習・予測・組み合わせ検証: 実行中はスケールで強調し、そのサイズを維持（遷移なし） */
        /* Data process & get-latest: no transform to avoid layout shift */
    #dataProcessBtn.running, #getLatestBtn.running {
            box-shadow: 0 0 20px rgba(255,0,255,0.95), 0 0 44px rgba(255,0,255,0.45);
            background: linear-gradient(45deg,#ff00ff,#ff66ff);
            color: #fff;
            transform: none !important;
            border-color: rgba(255,0,255,0.9);
            transition: none !important;
        }
        /* Train & Predict & Optimize Years: apply scaled appearance while running and keep it fixed (no transition) */
    #trainBtn.running, #predictBtn.running, #optimizeYearsBtn.running {
            box-shadow: 0 0 20px rgba(255,0,255,0.95), 0 0 44px rgba(255,0,255,0.45);
            background: linear-gradient(45deg,#ff00ff,#ff66ff);
            color: #fff;
            transform: scale(1.04) !important;
            border-color: rgba(255,0,255,0.9);
            transition: none !important;
        }

        /* ツールチップスタイル */
        .tooltip {
            position: relative;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 280px;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            text-align: left;
            border-radius: 8px;
            padding: 12px;
            position: absolute;
            z-index: 9999;
            bottom: 12%; /* default: show slightly above the element */
            left: 50%;
            transform: translateX(-50%);
            margin: 0; /* use transform for centering */
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.2);
            font-size: 13px;
            line-height: 1.4;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.95) transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        /* キーボード操作でもツールチップを表示できるようにする */
        .tooltip:focus-within .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .tooltip .tooltiptext strong {
            color: #00ffff;
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
        }
        .tooltip .tooltiptext .formula {
            font-family: 'Courier New', monospace;
            background: rgba(0, 255, 255, 0.1);
            padding: 3px 6px;
            border-radius: 4px;
            margin: 4px 0;
            font-size: 12px;
        }

        /* Ensure main action buttons keep a stable width when their text changes (e.g. '実行中...') */
        #dataProcessBtn, #trainBtn, #getLatestBtn, #predictBtn, #optimizeYearsBtn {
            min-width: 140px; /* adjust if you prefer wider/narrower */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            padding-left: 10px; padding-right: 10px;
            box-sizing: border-box;
        }
        /* Disabled appearance should not collapse width */
        #dataProcessBtn[disabled], #trainBtn[disabled], #getLatestBtn[disabled], #predictBtn[disabled], #optimizeYearsBtn[disabled] {
            opacity: 0.95;
            cursor: not-allowed;
        }
     .controls { display:flex; gap:8px; flex-wrap:wrap }
     /* アクション行: ボタン（左）と指標（右）を横並びにする
         学習カードではボタンの下に指標を横並びで置くため、左カラムを縦積みにする */
     .actions-row { display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-top:10px }
     .actions-row .left { display:flex; flex-direction:column; gap:8px; align-items:flex-start }
     .actions-row .left .btn-row { display:flex; gap:8px }
     .actions-row .right { display:flex; gap:12px; align-items:center }
    /* 年ボタンと処理/学習ボタンを同一行にするラッパー */
    .year-action-row { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-top:6px }
    .year-action-row > div:first-child { flex:1 }
    .btn-col, .year-action-row .btn-col { display:flex; flex-direction:column; align-items:flex-end }
    /* モデル選択ボタンは 2カラム×2行 のグリッドにする */
    #modelButtons { display: grid; grid-template-columns: repeat(2, 1fr); gap:8px; align-items: stretch; }
    #modelButtons .btn { width: 100%; text-align: center; padding: 10px 12px; }

    /* Make .btn-row a no-wrap flex container so buttons inside are always side-by-side and equally sized */
    .btn-row {
        display: flex;
        gap: 8px;
        flex-wrap: nowrap;
        align-items: center;
    }
    .btn-row .btn {
        flex: 1 1 0;
        max-width: 50%;
        box-sizing: border-box;
        text-align: center;
    }

    /* ボタンに被らないよう、ボタンラッパー用ツールチップはボタンの上方に表示する */
    .btn-row .tooltip { display: inline-block; }
    .btn-row .tooltip .tooltiptext {
        bottom: calc(100% + 8px); /* ボタンの上方に出す（ボタンに重ならない） */
        left: 50%;
        transform: translateX(-50%);
        pointer-events: none; /* ツールチップでボタン操作を妨げない */
        max-width: 320px;
    }

    /* 学習年カードの組み合わせ検証ボタンのツールチップも上方に表示 */
    #optimizeYearsBtn + .tooltiptext {
        bottom: calc(100% + 8px) !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        top: auto !important;
        pointer-events: none;
    }

        .year-buttons { display:flex; gap:6px; flex-wrap:wrap }
            /* Year buttons: default glow, deselected => inverted. Use #yearContainer scoped rules to override globals */
            /* make glow match primary.active neon appearance */
            #yearContainer .btn.glow {
                background: linear-gradient(45deg,#00ff88,#00ffb3) !important;
                color: #002200 !important;
                border: 1px solid rgba(0,255,136,0.9) !important;
                box-shadow: 0 0 18px rgba(0,255,136,0.9), 0 0 40px rgba(0,255,136,0.4) !important;
            }
            #yearContainer .btn.inverted {
                background: linear-gradient(45deg, rgba(0,255,136,0.18), rgba(0,255,136,0.06)) !important;
                color: #00ff88 !important;
                border: 1px solid rgba(0,255,136,0.6) !important;
                box-shadow: 0 0 10px rgba(0,255,136,0.18) !important;
            }
    .chart-area { margin-top: 12px; height: 420px; }
    /* chart-area specific tooltip: show near bottom center of image to avoid being too high */
    .chart-area .tooltip .tooltiptext {
        bottom: 8%;
        left: 50%;
        transform: translateX(-50%);
        max-width: 320px;
            pointer-events: none; /* avoid blocking clicks on image */
    }
        /* When modal is open, hide all tooltips to avoid blocking controls */
        .modal-open .tooltip .tooltiptext { display: none !important; visibility: hidden !important; opacity: 0 !important; }
    /* Ensure PNG images sit above the canvas and receive pointer events so clicks open modal */
    .chart-area { position: relative; }
    .chart-area img { position: relative; z-index: 2; pointer-events: auto; }
    .chart-area canvas { position: relative; z-index: 1; }
    /* modal for enlarged PNG */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.75); display: none; align-items: center; justify-content: center; z-index: 9999 }
    .modal-overlay.show { display: flex; }
    .modal-img { max-width: 96%; max-height: 92%; box-shadow: 0 8px 40px rgba(0,0,0,0.6); border-radius: 6px; background: #000 }
    .modal-close { position: absolute; top: 18px; right: 22px; color: #fff; font-size: 22px; cursor: pointer; background: rgba(0,0,0,0.25); padding:6px 10px; border-radius:6px }
    .modal-controls { position: absolute; top: 18px; left: 22px; display:flex; gap:8px; z-index: 10000 }
    .modal-btn { background: rgba(0,0,0,0.35); color: #fff; border: none; padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:bold }
    .modal-btn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(0,0,0,0.6) }
    #trainImage, #predImage { cursor: zoom-in }
        .stats { display:flex; gap:12px; margin-top:12px }
        .stat { flex:1; background: rgba(0,0,0,0.25); padding:10px; border-radius:6px; text-align:center }
        @media (max-width: 1200px) {
            .title { font-size: 2rem; }
            .container { max-width: 95%; }
        }
        @media (max-width: 768px) {
            .title { font-size: 1.5rem; }
            .container { padding: 15px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">電力需要AI予測ダッシュボード</h1>
        </div>

        <div class="grid">
            <div class="card">
                <h3>モデル</h3>
<div class="controls" id="modelButtons">
                    <button class="btn primary" data-model="Keras">Keras</button>
                    <button class="btn primary active" data-model="LightGBM">LightGBM</button>
                    <button class="btn primary" data-model="Pycaret">Pycaret</button>
                    <button class="btn primary" data-model="RandomForest">RandomForest</button>
                </div>
            </div>

            <div class="card">
                <h3>予測</h3>
                <div class="btn-row" style="margin-bottom:8px">
                    <div class="tooltip" style="display:inline-block">
                        <button id="getLatestBtn" class="btn">最新データ取得</button>
                        <span class="tooltiptext" role="tooltip">
                            <strong>最新データ取得</strong>
                            予測を実行する前に1回だけ実行してください（全モデル共通）。
                        </span>
                    </div>
                    <div class="tooltip" style="display:inline-block">
                        <button id="predictBtn" class="btn">予測</button>
                        <span class="tooltiptext" role="tooltip">
                            <strong>予測</strong>
                            選択したモデルで予測を実行します（事前に1回だけ最新データ取得を実行してください）。
                        </span>
                    </div>
                </div>
                <div class="stats" style="margin-top:10px">
                    <div class="stat tooltip">
                        RMSE<br><span id="predRmse">-</span>
                        <span class="tooltiptext">
                            <strong>RMSE (Root Mean Squared Error)</strong>
                            二乗平均平方根誤差。予測値と実際値の差の平方平均の平方根です。
                            <div class="formula">√(Σ(予測値 - 実際値)² / n)</div>
                            値が小さいほど予測精度が高いことを示します。単位は予測対象と同じ（この場合はkW）です。
                        </span>
                    </div>
                    <div class="stat tooltip">
                        R2<br><span id="predR2">-</span>
                        <span class="tooltiptext">
                            <strong>R² (決定係数)</strong>
                            モデルの予測性能を表す指標で、0〜1の値を取ります。
                            <div class="formula">1 - (残差平方和 / 全平方和)</div>
                            1に近いほど予測精度が高く、0.9以上なら非常に良好な予測性能を示します。
                        </span>
                    </div>
                    <div class="stat tooltip">
                        MAE<br><span id="predMae">-</span>
                        <span class="tooltiptext">
                            <strong>MAE (Mean Absolute Error)</strong>
                            平均絶対誤差。予測値と実際値の差の絶対値の平均です。
                            <div class="formula">Σ|予測値 - 実際値| / n</div>
                            外れ値の影響を受けにくく、平均的な予測誤差を表します。値が小さいほど良好です。
                        </span>
                    </div>
                    <div class="stat">モデル<br><span id="predModelName">-</span></div>
                </div>
            </div>

            <div class="card">
                <h3>学習</h3>
                <div style="margin-bottom:8px">
                    <div class="btn-row">
                        <div class="tooltip" style="display:inline-block">
                            <button id="dataProcessBtn" class="btn">データ処理</button>
                            <span class="tooltiptext" role="tooltip">
                                <strong>データ処理</strong>
                                学習年を更新する場合のみ1回だけ実行してください（全モデル共通）。
                            </span>
                        </div>
                        <div class="tooltip" style="display:inline-block">
                            <button id="trainBtn" class="btn">学習</button>
                            <span class="tooltiptext" role="tooltip">
                                <strong>学習</strong>
                                選択したモデルを学習します（学習年を更新する場合、事前に1回だけデータ処理を実行ください）。
                            </span>
                        </div>
                    </div>
                </div>
                <div class="stats" style="margin-top:10px">
                    <div class="stat tooltip">
                        RMSE<br><span id="trainRmse">-</span>
                        <span class="tooltiptext">
                            <strong>RMSE (Root Mean Squared Error)</strong>
                            二乗平均平方根誤差。予測値と実際値の差の平方平均の平方根です。
                            <div class="formula">√(Σ(予測値 - 実際値)² / n)</div>
                            値が小さいほど予測精度が高いことを示します。単位は予測対象と同じ（この場合はkW）です。
                        </span>
                    </div>
                    <div class="stat tooltip">
                        R2<br><span id="trainR2">-</span>
                        <span class="tooltiptext">
                            <strong>R² (決定係数)</strong>
                            モデルの予測性能を表す指標で、0〜1の値を取ります。
                            <div class="formula">1 - (残差平方和 / 全平方和)</div>
                            1に近いほど予測精度が高く、0.9以上なら非常に良好な予測性能を示します。
                        </span>
                    </div>
                    <div class="stat tooltip">
                        MAE<br><span id="trainMae">-</span>
                        <span class="tooltiptext">
                            <strong>MAE (Mean Absolute Error)</strong>
                            平均絶対誤差。予測値と実際値の差の絶対値の平均です。
                            <div class="formula">Σ|予測値 - 実際値| / n</div>
                            外れ値の影響を受けにくく、平均的な予測誤差を表します。値が小さいほど良好です。
                        </span>
                    </div>
                    <div class="stat">モデル<br><span id="trainModelName">-</span></div>
                </div>
            </div>

            <div class="card">
                <h3>学習年</h3>
                <div>
                    <div id="yearContainer" class="year-buttons"></div>
                </div>
                <div style="margin-top:12px">
                    <div class="tooltip" style="display:inline-block">
                        <button id="optimizeYearsBtn" class="btn">組み合わせ検証シミュレーション</button>
                        <span class="tooltiptext" role="tooltip">
                            <strong>組み合わせ検証</strong>
                            選択したモデルで最適な組み合わせ学習年を検証します（※Kerasは十数分、それ以外は数分で処理）。
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <div class="grid" style="margin-top:16px; grid-template-columns: 1fr 1fr;">
            <div class="card">
                <h3>予測グラフ</h3>
                <div class="chart-area">
                    <div id="predChartWrapper" class="tooltip" tabindex="0" role="button" aria-label="予測グラフを拡大表示">
                        <img id="predImage" src="" alt="pred graph" style="display:none; width:100%; height:100%; object-fit:contain;" />
                        <span class="tooltiptext" role="tooltip">
                            <strong>クリックで拡大</strong>
                            画像を拡大表示します。モーダル内でダウンロードできます。
                        </span>
                    </div>
                </div>
            </div>
            <div class="card">
                <h3>学習グラフ</h3>
                <div class="chart-area">
                    <div id="trainChartWrapper" class="tooltip" tabindex="0" role="button" aria-label="学習グラフを拡大表示">
                        <img id="trainImage" src="" alt="train graph" style="display:none; width:100%; height:100%; object-fit:contain;" />
                        <span class="tooltiptext" role="tooltip">
                            <strong>クリックで拡大</strong>
                            画像を拡大表示します。モーダル内でダウンロードできます。
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal overlay for enlarged images (placed before script so elements exist when JS runs) -->
    <div id="imgModal" class="modal-overlay" role="dialog" aria-hidden="true">
        <div class="modal-close" id="imgModalClose">✕</div>
        <div class="modal-controls" role="toolbar" aria-label="Image controls">
            <button id="modalZoomIn" class="modal-btn" title="ズームイン">＋</button>
            <button id="modalZoomOut" class="modal-btn" title="ズームアウト">－</button>
            <button id="modalFullscreen" class="modal-btn" title="全画面">⤢</button>
            <button id="modalDownload" class="modal-btn" title="ダウンロード">⬇</button>
        </div>
        <img id="imgModalImg" class="modal-img" src="" alt="enlarged graph" />
    </div>

    <script>
        // Pyodide instance (global)
        let pyodide = null;
        let pyodideReady = false;

        // Initialize Pyodide and load required packages
        async function initPyodide(){
            if(pyodideReady) return pyodide;
            try{
                console.log('Loading Pyodide...');
                pyodide = await loadPyodide();
                console.log('Pyodide loaded. Installing packages...');
                // Install essential packages (lightweight subset for browser)
                await pyodide.loadPackage(['numpy', 'pandas', 'matplotlib', 'scikit-learn']);
                console.log('Packages installed. Preloading CSV files...');
                
                // Preload CSV files into Pyodide virtual filesystem
                const years = ['2016','2017','2018','2019','2020','2021','2022','2023','2024','2025'];
                // Create directories
                pyodide.FS.mkdir('/data');
                pyodide.FS.mkdir('/train');
                pyodide.FS.mkdir('/tomorrow');
                for(const model of ['LightGBM','Keras','RandomForest','Pycaret']){
                    pyodide.FS.mkdir(`/train/${model}`);
                    pyodide.FS.mkdir(`/tomorrow/${model}`);
                }
                
                // Preload data CSVs (juyo, temperature)
                for(const year of years){
                    try{
                        const juyoResp = await fetch(`./data/juyo-${year}.csv`);
                        if(juyoResp.ok){
                            const juyoData = await juyoResp.arrayBuffer();
                            pyodide.FS.writeFile(`/data/juyo-${year}.csv`, new Uint8Array(juyoData));
                        }
                        const tempResp = await fetch(`./data/temperature-${year}.csv`);
                        if(tempResp.ok){
                            const tempData = await tempResp.arrayBuffer();
                            pyodide.FS.writeFile(`/data/temperature-${year}.csv`, new Uint8Array(tempData));
                        }
                    }catch(e){
                        console.warn(`Failed to load year ${year}:`, e);
                    }
                }
                
                // Preload processed data (Xtrain, Ytrain, etc.)
                for(const file of ['X.csv','Y.csv','Xtrain.csv','Ytrain.csv','Xtest.csv','Ytest.csv']){
                    try{
                        const resp = await fetch(`./data/${file}`);
                        if(resp.ok){
                            const data = await resp.arrayBuffer();
                            pyodide.FS.writeFile(`/data/${file}`, new Uint8Array(data));
                        }
                    }catch(e){
                        console.warn(`Failed to load ${file}:`, e);
                    }
                }
                
                console.log('CSV preloading complete.');
                pyodideReady = true;
                return pyodide;
            }catch(e){
                console.error('Pyodide initialization failed:', e);
                alert('Pyodide の初期化に失敗しました。一部の機能が利用できません。');
                return null;
            }
        }

        // 初期化
        const modelButtons = document.querySelectorAll('#modelButtons .btn');
        let selectedModel = 'LightGBM';
        modelButtons.forEach(b => b.addEventListener('click', async () => {
            modelButtons.forEach(x => x.classList.remove('active'));
            b.classList.add('active');
            selectedModel = b.dataset.model;
            // 選択モデル名を UI に表示（存在すれば）
            const selEl = document.getElementById('selectedModelName');
            if(selEl) selEl.textContent = selectedModel;
            // 学習/予測のモデル名表示を更新し、指標はクリアして古い値を残さない
            const trainNameEl = document.getElementById('trainModelName');
            const predNameEl = document.getElementById('predModelName');
            if(trainNameEl) trainNameEl.textContent = selectedModel;
            if(predNameEl) predNameEl.textContent = selectedModel;
            ['trainRmse','trainR2','trainMae','predRmse','predR2','predMae'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='-'; });
            // update charts when model changes
            try{ await loadTrainChart(selectedModel); }catch(e){ console.warn('train chart update failed', e); }
            try{ await loadPredChart(selectedModel); }catch(e){ console.warn('pred chart update failed', e); }
            // 選択変更時にクライアント側で指標を再計算して表示
            try{ await updateTrainMetrics(selectedModel); }catch(e){ console.warn('updateTrainMetrics failed', e); }
            try{ await updatePredMetrics(selectedModel); }catch(e){ console.warn('updatePredMetrics failed', e); }
        }));

        // 年の自動検出: 静的サイトのため固定リストを返す（server.py が無い環境用）
        async function loadAvailableYears(){
            // Static list of available years for GitHub Pages deployment
            return ['2016','2017','2018','2019','2020','2021','2022','2023','2024','2025'];
        }

        // Build relative URL for static GitHub Pages deployment (no server.py)
        function buildUrl(path){
            try{
                if(!path) return path;
                // If already absolute (starts with http), return as-is
                if(path.startsWith('http://') || path.startsWith('https://')) return path;
                // For GitHub Pages, use relative paths from docs/ root
                // Remove leading slash if present to make it relative
                let rel = path.startsWith('/') ? path.substring(1) : path;
                // Prepend './' to ensure relative resolution
                return './' + rel;
            }catch(e){ return path; }
        }

        function renderYearButtons(years){
            const cont = document.getElementById('yearContainer');
            cont.innerHTML = '';
            years.forEach(y=>{
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.textContent = y;
                btn.dataset.year = y;
                // default: glow
                btn.classList.add('glow');
                btn.onclick = async ()=>{ 
                    // toggle active state
                    btn.classList.toggle('active');
                    if(btn.classList.contains('active')){
                        // selected -> show glow (keep glow), remove inverted
                        btn.classList.remove('inverted');
                        btn.classList.add('glow');
                    } else {
                        // deselected -> inverted, remove glow
                        btn.classList.remove('glow');
                        btn.classList.add('inverted');
                    }
                    updateSelectedYearsDisplay();
                    // update train chart when year selection changes
                    try{ await loadTrainChart(selectedModel); }catch(e){ console.warn('train chart update failed', e); }
                };
                cont.appendChild(btn);
            });
            // デフォルト全選択 (active) — keep glow
            Array.from(cont.children).forEach(c=>{ c.classList.add('active'); c.classList.remove('inverted'); c.classList.add('glow'); });
            updateSelectedYearsDisplay();
        }

        function updateSelectedYearsDisplay(){
            const yearBtns = Array.from(document.querySelectorAll('#yearContainer .btn'));
            const selected = yearBtns.filter(b=>b.classList.contains('active')).map(b=>b.dataset.year);
            const el = document.getElementById('selectedYears');
            if(!el) return;
            el.textContent = selected.length ? selected.join(',') : 'なし';
        }

        async function init(){
            // Initialize Pyodide in background (non-blocking)
            initPyodide().catch(e => console.warn('Pyodide init async failed:', e));
            const years = await loadAvailableYears();
            renderYearButtons(years);
            // initial chart loads for default model
            try{ await loadTrainChart(selectedModel); }catch(e){ console.warn('initial train chart failed', e); }
            try{ await loadPredChart(selectedModel); }catch(e){ console.warn('initial pred chart failed', e); }
        }
        init();

        // ヘルパ: stdout から各種表記のスコアを抽出する（強化版v2）
        function extractMetric(txt, names){
            if(!txt) return null;
            
            // パターン1: 統一フォーマット「最終結果 - RMSE: X kW, R2スコア: Y, MAE: Z kW」を優先
            // R2の表記バリエーション: R2スコア | R2 | R²スコア | R2 score | R² score
            const finalPattern = /最終結果[^0-9]*(?:RMSE|REG\s*RMSE)[:\s]*([0-9.]+)[^,]*,\s*(?:R2スコア|R2|R²スコア|R2\s*score|R²\s*score|R\^2)[:\s]*([+-]?[0-9.]+)[^,]*,\s*(?:MAE)[:\s]*([0-9.]+)/i;
            const finalMatch = txt.match(finalPattern);
            if(finalMatch){
                const lowerNames = names.map(n => n.toLowerCase());
                if(lowerNames.some(n => ['rmse', 'root mean squared error', 'reg rmse'].includes(n.toLowerCase()))) return finalMatch[1];
                if(lowerNames.some(n => ['r2', 'r2スコア', 'r2 score', 'r^2', 'r²スコア', 'r² score', 'reg score', 'スコア'].includes(n.toLowerCase()))) return finalMatch[2];
                if(lowerNames.some(n => ['mae', 'mean absolute error'].includes(n.toLowerCase()))) return finalMatch[3];
            }
            
            // パターン2: 個別行パターン「RMSE: X」「R2 Score: Y」「MAE: Z」(Keras tomorrowレガシー形式対応)
            // 各指標が別行で出力される場合に対応
            const lowerNames = names.map(n => n.toLowerCase());
            if(lowerNames.some(n => ['rmse', 'root mean squared error', 'reg rmse'].includes(n.toLowerCase()))){
                const rmseLinePattern = /^(?:RMSE|REG\s*RMSE)[:\s]*([+-]?[0-9.]+)/im;
                const rmseLineMatch = txt.match(rmseLinePattern);
                if(rmseLineMatch) return rmseLineMatch[1];
            }
            if(lowerNames.some(n => ['r2', 'r2スコア', 'r2 score', 'r^2', 'r²スコア', 'r² score', 'reg score', 'スコア'].includes(n.toLowerCase()))){
                const r2LinePattern = /^(?:R2|R2\s*score|R2スコア|R²スコア|R²\s*score|R\^2)[:\s]*([+-]?[0-9.]+)/im;
                const r2LineMatch = txt.match(r2LinePattern);
                if(r2LineMatch) return r2LineMatch[1];
            }
            if(lowerNames.some(n => ['mae', 'mean absolute error'].includes(n.toLowerCase()))){
                const maeLinePattern = /^(?:MAE|Mean\s*Absolute\s*Error)[:\s]*([+-]?[0-9.]+)/im;
                const maeLineMatch = txt.match(maeLinePattern);
                if(maeLineMatch) return maeLineMatch[1];
            }
            
            // パターン3: 汎用パターン（既存の柔軟マッチング）
            const esc = names.map(s => s.replace(/[\\/\^$*+?.()|[\]{}]/g,'\\$&'));
            const alt = esc.join('|');
            const re = new RegExp('(?:' + alt + ')\\s*(?:[:：=\\-]|is)?\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)(?:\\s*(?:kW|%)?)?', 'i');
            const m = txt.match(re);
            if(m && m[1]) return m[1];
            
            return null;
        }

        // 実行ボタンハンドラ
        async function postJson(path, body, button=null){
            try{
                if(button){ button.classList.add('running'); }
                const res = await fetch(buildUrl(path), { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
                const j = await res.json();
                return j;
            }catch(e){
                throw e;
            }finally{
                if(button){ setTimeout(()=>{ button.classList.remove('running'); }, 800); }
                // update inverted style for model buttons
                updateInvertedModelButtons();
            }
        }

        document.getElementById('dataProcessBtn').addEventListener('click', async ()=>{
            const btn = document.getElementById('dataProcessBtn');
            const years = Array.from(document.querySelectorAll('#yearContainer .btn.active')).map(b=>b.dataset.year);
            if(!pyodideReady){
                alert('Pyodide がまだ準備中です。しばらく待ってから再試行してください。');
                return;
            }
            btn.textContent = '実行中...'; btn.disabled = true; btn.classList.add('running');
            try{
                console.log('Running data processing with years:', years);
                // Simplified data processing using Pyodide (read CSVs, merge, split, save)
                const pythonCode = `
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split

# Read juyo and temperature CSVs for selected years
years = ${JSON.stringify(years)}
data_frames = []
for year in years:
    try:
        juyo_path = f'./data/juyo-{year}.csv'
        temp_path = f'./data/temperature-{year}.csv'
        # Read CSVs (skip header rows as per data.py)
        juyo_df = pd.read_csv(juyo_path, skiprows=3, encoding='shift_jis', names=['DATE','TIME','KW'], usecols=[0,1,2])
        temp_df = pd.read_csv(temp_path, skiprows=5, encoding='shift_jis')
        # Merge and process (simplified: assume same length and order)
        merged = juyo_df.copy()
        merged['TEMP'] = temp_df.iloc[:, 2] if len(temp_df.columns) > 2 else 0
        merged['MONTH'] = pd.to_datetime(merged['DATE']).dt.month
        merged['WEEK'] = pd.to_datetime(merged['DATE']).dt.dayofweek
        merged['HOUR'] = merged['TIME'].str.split(':').str[0].astype(int)
        data_frames.append(merged[['MONTH','WEEK','HOUR','TEMP','KW']])
    except Exception as e:
        print(f'Error loading year {year}: {e}')

# Concatenate all years
data = pd.concat(data_frames, ignore_index=True)
X = data[['MONTH','WEEK','HOUR','TEMP']]
Y = data[['KW']]

# Train-test split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1, random_state=42)

# Save to CSV (in-memory, then convert to download)
X.to_csv('./data/X.csv', index=False)
Y.to_csv('./data/Y.csv', index=False)
X_train.to_csv('./data/Xtrain.csv', index=False)
X_test.to_csv('./data/Xtest.csv', index=False)
Y_train.to_csv('./data/Ytrain.csv', index=False)
Y_test.to_csv('./data/Ytest.csv', index=False)

print('Data processing complete.')
"done"
`;
                const result = await pyodide.runPythonAsync(pythonCode);
                console.log('Data processing result:', result);
                alert('データ処理完了');
            }catch(e){
                console.error('Data processing error:', e);
                alert('エラー: ' + e);
            }
            btn.textContent = 'データ処理'; btn.disabled = false; btn.classList.remove('running');
        });

    document.getElementById('trainBtn').addEventListener('click', async ()=>{
            const btn = document.getElementById('trainBtn');
            if(!pyodideReady){
                alert('Pyodide がまだ準備中です。しばらく待ってから再試行してください。');
                return;
            }
            btn.textContent='実行中...'; btn.disabled=true; btn.classList.add('running');
            try{
                const yearBtns = Array.from(document.querySelectorAll('#yearContainer .btn'));
                const selectedYears = yearBtns.filter(b=>b.classList.contains('active')).map(b=>b.dataset.year);
                console.log('Training model:', selectedModel, 'with years:', selectedYears);
                // Simplified training using scikit-learn RandomForest (LightGBM not available in Pyodide)
                const pythonCode = `
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import io
import base64

# Load train/test data
X_train = pd.read_csv('./data/Xtrain.csv')
X_test = pd.read_csv('./data/Xtest.csv')
Y_train = pd.read_csv('./data/Ytrain.csv').values.ravel()
Y_test = pd.read_csv('./data/Ytest.csv').values.ravel()

# Scale features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train RandomForest
model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=1)
model.fit(X_train_scaled, Y_train)

# Predict
Y_pred = model.predict(X_test_scaled)

# Compute metrics
rmse = np.sqrt(mean_squared_error(Y_test, Y_pred))
r2 = r2_score(Y_test, Y_pred)
mae = mean_absolute_error(Y_test, Y_pred)

# Save predictions
pd.DataFrame(Y_pred, columns=['KW']).to_csv(f'./train/{selectedModel}/{selectedModel}_Ypred.csv', index=False)

# Plot (in-memory, then convert to base64)
fig, ax = plt.subplots(figsize=(16, 9))
ax.plot(Y_test, label='Actual', color='cyan')
ax.plot(Y_pred, label='Predicted', color='magenta', alpha=0.7)
ax.set_title('Training Results', fontsize=14)
ax.set_xlabel('Sample', fontsize=12)
ax.set_ylabel('KW', fontsize=12)
ax.legend()
ax.grid(alpha=0.3)
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode('utf-8')
buf.close()
plt.close(fig)

# Return metrics and image
{"rmse": rmse, "r2": r2, "mae": mae, "img": img_base64}
`.replace('${selectedModel}', selectedModel);
                const resultObj = await pyodide.runPythonAsync(pythonCode);
                const result = resultObj.toJs({dict_converter: Object.fromEntries});
                console.log('Training result:', result);
                // Update UI
                document.getElementById('trainRmse').textContent = result.rmse.toFixed(2);
                document.getElementById('trainR2').textContent = result.r2.toFixed(3);
                document.getElementById('trainMae').textContent = result.mae.toFixed(3);
                document.getElementById('trainModelName').textContent = selectedModel;
                // Display PNG (base64)
                const trainImg = document.getElementById('trainImage');
                trainImg.src = 'data:image/png;base64,' + result.img;
                trainImg.style.display = 'block';
                alert('学習完了');
            }catch(e){
                console.error('Training error:', e);
                alert('エラー: ' + e);
            }
            btn.textContent='学習'; btn.disabled=false; btn.classList.remove('running');
            try{ await loadTrainChart(selectedModel); }catch(e){ console.warn('train chart load failed', e); }
            try{ await updateTrainMetrics(selectedModel); }catch(e){ console.warn('updateTrainMetrics post-train failed', e); }
        });

    document.getElementById('getLatestBtn').addEventListener('click', async ()=>{
            const btn = document.getElementById('getLatestBtn');
            if(!pyodideReady){
                alert('Pyodide がまだ準備中です。しばらく待ってから再試行してください。');
                return;
            }
            btn.textContent='実行中...'; btn.disabled=true; btn.classList.add('running');
            try{
                // Note: CORS restrictions may prevent direct TEPCO API access from browser
                const pythonCode = `
import pandas as pd
import datetime
try:
    # Attempt to fetch TEPCO data (may fail due to CORS)
    import pyodide_http
    pyodide_http.patch_all()
    url = 'http://www.tepco.co.jp/forecast/html/images/juyo-j.csv'
    df = pd.read_csv(url, encoding='shift_jis', skiprows=2, header=None)
    df = df.iloc[:, [0, 1]]
    df.columns = ['DateTime', 'KW']
    df['DateTime'] = pd.to_datetime(df['DateTime'], format='%Y/%m/%d %H:%M', errors='coerce')
    df = df.dropna()
    tomorrow = datetime.datetime.now() + datetime.timedelta(days=1)
    df_tomorrow = df[df['DateTime'].dt.date == tomorrow.date()]
    if df_tomorrow.empty:
        result = {"status": "error", "message": "明日のデータが見つかりません（TEPCO CSV未更新）"}
    else:
        df_tomorrow.to_csv('./tomorrow/tomorrow.csv', index=False)
        result = {"status": "success", "message": f"明日のデータ取得完了: {len(df_tomorrow)} 件", "count": len(df_tomorrow)}
except Exception as e:
    result = {"status": "error", "message": f"CORS制約により直接取得不可: {str(e)}。静的CSVを使用してください。"}
result
`;
                const resultObj = await pyodide.runPythonAsync(pythonCode);
                const result = resultObj.toJs({dict_converter: Object.fromEntries});
                console.log('getLatest result:', result);
                alert(result.message);
            }catch(e){
                console.error('getLatest error:', e);
                alert('エラー: ' + e);
            }
            btn.textContent='最新データ取得'; btn.disabled=false; btn.classList.remove('running');
            // refresh pred chart after latest data fetched
            try{ await loadPredChart(selectedModel); }catch(e){ console.warn('pred chart load after latest data failed', e); }
        });

    document.getElementById('predictBtn').addEventListener('click', async ()=>{
            const btn = document.getElementById('predictBtn');
            if(!pyodideReady){
                alert('Pyodide がまだ準備中です。しばらく待ってから再試行してください。');
                return;
            }
            btn.textContent='実行中...'; btn.disabled=true; btn.classList.add('running');
            try{
                const yearBtns = Array.from(document.querySelectorAll('#yearContainer .btn'));
                const selectedYears = yearBtns.filter(b=>b.classList.contains('active')).map(b=>b.dataset.year);
                console.log('Predicting with model:', selectedModel, 'years:', selectedYears);
                // Simplified prediction: train model on historical data, predict on tomorrow's data
                const pythonCode = `
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import io
import base64

# Load train data
X_train = pd.read_csv('./data/Xtrain.csv')
Y_train = pd.read_csv('./data/Ytrain.csv').values.ravel()

# Load tomorrow's data (if exists from getLatestBtn)
try:
    tomorrow_df = pd.read_csv('./tomorrow/tomorrow.csv')
    # Extract features from DateTime
    tomorrow_df['DateTime'] = pd.to_datetime(tomorrow_df['DateTime'])
    tomorrow_df['MONTH'] = tomorrow_df['DateTime'].dt.month
    tomorrow_df['WEEK'] = tomorrow_df['DateTime'].dt.dayofweek
    tomorrow_df['HOUR'] = tomorrow_df['DateTime'].dt.hour
    # Assume TEMP=15 if no temperature data (placeholder)
    tomorrow_df['TEMP'] = 15
    X_tomorrow = tomorrow_df[['MONTH','WEEK','HOUR','TEMP']]
    Y_tomorrow = tomorrow_df['KW'].values if 'KW' in tomorrow_df.columns else None
except Exception as e:
    # Fallback: generate synthetic tomorrow data (24 hours)
    print(f'No tomorrow.csv found, using fallback: {e}')
    import datetime
    tomorrow = datetime.datetime.now() + datetime.timedelta(days=1)
    hours = pd.date_range(start=tomorrow.replace(hour=0, minute=0, second=0), periods=24, freq='H')
    X_tomorrow = pd.DataFrame({
        'MONTH': [h.month for h in hours],
        'WEEK': [h.weekday() for h in hours],
        'HOUR': [h.hour for h in hours],
        'TEMP': [15] * 24
    })
    Y_tomorrow = None

# Scale and train
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_tomorrow_scaled = scaler.transform(X_tomorrow)

model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=1)
model.fit(X_train_scaled, Y_train)

# Predict tomorrow
Y_pred = model.predict(X_tomorrow_scaled)

# Compute metrics if Y_tomorrow exists
if Y_tomorrow is not None and len(Y_tomorrow) == len(Y_pred):
    rmse = np.sqrt(mean_squared_error(Y_tomorrow, Y_pred))
    r2 = r2_score(Y_tomorrow, Y_pred)
    mae = mean_absolute_error(Y_tomorrow, Y_pred)
else:
    rmse = r2 = mae = 0

# Save predictions
pd.DataFrame({'KW': Y_pred}).to_csv(f'./tomorrow/{selectedModel}/{selectedModel}_tomorrow.csv', index=False)

# Plot
fig, ax = plt.subplots(figsize=(16, 9))
ax.plot(Y_pred, label='Predicted KW', color='magenta', marker='o')
if Y_tomorrow is not None and len(Y_tomorrow) == len(Y_pred):
    ax.plot(Y_tomorrow, label='Actual KW', color='cyan', marker='x')
ax.set_title('Tomorrow Prediction', fontsize=14)
ax.set_xlabel('Hour', fontsize=12)
ax.set_ylabel('KW', fontsize=12)
ax.legend()
ax.grid(alpha=0.3)
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode('utf-8')
buf.close()
plt.close(fig)

{"rmse": rmse, "r2": r2, "mae": mae, "img": img_base64}
`.replace('${selectedModel}', selectedModel);
                const resultObj = await pyodide.runPythonAsync(pythonCode);
                const result = resultObj.toJs({dict_converter: Object.fromEntries});
                console.log('Prediction result:', result);
                // Update UI
                if(result.rmse > 0){
                    document.getElementById('predRmse').textContent = result.rmse.toFixed(2);
                    document.getElementById('predR2').textContent = result.r2.toFixed(3);
                    document.getElementById('predMae').textContent = result.mae.toFixed(3);
                } else {
                    ['predRmse','predR2','predMae'].forEach(id=>{ document.getElementById(id).textContent = '-'; });
                }
                document.getElementById('predModelName').textContent = selectedModel;
                // Display PNG
                const predImg = document.getElementById('predImage');
                predImg.src = 'data:image/png;base64,' + result.img;
                predImg.style.display = 'block';
                alert('予測完了');
            }catch(e){
                console.error('Prediction error:', e);
                alert('エラー: ' + e);
            }
            btn.textContent='予測'; btn.disabled=false; btn.classList.remove('running');
            // 予測完了後に予測グラフを更新
            const selEl2 = document.getElementById('selectedModelName');
            if(selEl2) selEl2.textContent = selectedModel;
            try{ await loadPredChart(selectedModel); }catch(e){ console.warn('pred chart load failed', e); }
            // After prediction, only show pred metrics if CSVs exist; otherwise clear them
            try{
                const predPath = buildUrl(`/tomorrow/${selectedModel}/${selectedModel}_tomorrow.csv`);
                const resp = await fetch(predPath);
                if(resp.ok){ await updatePredMetrics(selectedModel); }
                else {
                    ['predRmse','predR2','predMae','predModelName'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='-'; });
                }
            }catch(e){ console.warn('post-predict CSV check failed', e); }
        });

        document.getElementById('optimizeYearsBtn').addEventListener('click', async ()=>{
            const btn = document.getElementById('optimizeYearsBtn'); 
            if(!pyodideReady){
                alert('Pyodide がまだ準備中です。しばらく待ってから再試行してください。');
                return;
            }
            btn.textContent='実行中...'; 
            btn.disabled=true; 
            btn.classList.add('running');
            try{
                console.log('Optimizing year combinations for model:', selectedModel);
                // Simplified optimization: test all year combinations (2^10 = 1024 combinations)
                const pythonCode = `
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
from itertools import combinations
import datetime

years = [2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025]
results = []

# Test all combinations (limit to combinations of 5+ years to avoid too many iterations)
for r in range(5, len(years)+1):
    for year_combo in combinations(years, r):
        try:
            # Load data for selected years
            data_frames = []
            for year in year_combo:
                juyo_path = f'./data/juyo-{year}.csv'
                temp_path = f'./data/temperature-{year}.csv'
                juyo_df = pd.read_csv(juyo_path, skiprows=3, encoding='shift_jis', names=['DATE','TIME','KW'], usecols=[0,1,2])
                temp_df = pd.read_csv(temp_path, skiprows=5, encoding='shift_jis')
                merged = juyo_df.copy()
                merged['TEMP'] = temp_df.iloc[:, 2] if len(temp_df.columns) > 2 else 0
                merged['MONTH'] = pd.to_datetime(merged['DATE']).dt.month
                merged['WEEK'] = pd.to_datetime(merged['DATE']).dt.dayofweek
                merged['HOUR'] = merged['TIME'].str.split(':').str[0].astype(int)
                data_frames.append(merged[['MONTH','WEEK','HOUR','TEMP','KW']])
            
            # Concatenate and split
            data = pd.concat(data_frames, ignore_index=True)
            X = data[['MONTH','WEEK','HOUR','TEMP']]
            Y = data['KW'].values
            from sklearn.model_selection import train_test_split
            X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.1, random_state=42)
            
            # Scale and train
            scaler = StandardScaler()
            X_train_sc = scaler.fit_transform(X_train)
            X_test_sc = scaler.transform(X_test)
            model = RandomForestRegressor(n_estimators=50, random_state=42, n_jobs=1)
            model.fit(X_train_sc, Y_train)
            Y_pred = model.predict(X_test_sc)
            
            # Compute metrics
            rmse = np.sqrt(mean_squared_error(Y_test, Y_pred))
            r2 = r2_score(Y_test, Y_pred)
            results.append({'years': ','.join(map(str, year_combo)), 'rmse': rmse, 'r2': r2})
        except Exception as e:
            print(f'Error with years {year_combo}: {e}')

# Sort by R2 (descending)
results_df = pd.DataFrame(results).sort_values('r2', ascending=False)

# Save top 10
top10 = results_df.head(10)
timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
output_file = f'./train/${selectedModel}/{timestamp}_${selectedModel}_optimize_years.txt'
with open(output_file, 'w') as f:
    f.write(f"Top 10 year combinations for ${selectedModel}:\\n")
    for idx, row in top10.iterrows():
        f.write(f"Years: {row['years']}, RMSE: {row['rmse']:.2f}, R2: {row['r2']:.4f}\\n")

{"status": "success", "best_years": top10.iloc[0]['years'], "best_r2": top10.iloc[0]['r2'], "count": len(results_df)}
`.replace(/\${selectedModel}/g, selectedModel);
                const resultObj = await pyodide.runPythonAsync(pythonCode);
                const result = resultObj.toJs({dict_converter: Object.fromEntries});
                console.log('Optimize result:', result);
                alert(`組み合わせ検証終了: ${result.count} 組合せ検証完了\\n最良: ${result.best_years} (R2=${result.best_r2.toFixed(4)})`);
            }catch(e){
                console.error('Optimization error:', e);
                alert('エラー: ' + e);
            }
            btn.textContent='組み合わせ検証'; 
            btn.disabled=false; 
            btn.classList.remove('running');
        });

        // Helper to invert non-selected model buttons when not running
        function updateInvertedModelButtons(){
            const modelBtns = document.querySelectorAll('#modelButtons .btn');
            modelBtns.forEach(b=>{
                if(!b.classList.contains('active') && !b.classList.contains('running')){
                    b.classList.add('inverted');
                } else {
                    b.classList.remove('inverted');
                }
            });
        }

        // Ensure inverted state is set initially
        updateInvertedModelButtons();

        // --- Chart.js 初期化 ---
        let trainChartObj = null;
        let predChartObj = null;

        function createCharts(){
            // Only initialize charts if canvas elements exist
            const trainCanvasEl = document.getElementById('trainChart');
            const predCanvasEl = document.getElementById('predChart');
            try{
                if(trainCanvasEl && !trainChartObj){
                    const tctx = trainCanvasEl.getContext('2d');
                    trainChartObj = new Chart(tctx, {
                        type: 'line',
                        data: { labels: [], datasets: [{ label: 'Predict', data: [], borderColor: '#00ff88', backgroundColor: 'rgba(0,255,136,0.06)' }] },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { y: { display: false, grid: { display: false }, ticks: { display: false } }, x: { grid: { color: 'rgba(255,255,255,0.03)' } } }
                        }
                    });
                }
                if(predCanvasEl && !predChartObj){
                    const pctx = predCanvasEl.getContext('2d');
                    predChartObj = new Chart(pctx, {
                        type: 'line',
                        data: { labels: [], datasets: [ { label: 'Predict', data: [], borderColor: '#ff66ff', backgroundColor: 'rgba(255,0,255,0.06)' }, { label: 'Actual', data: [], borderColor: '#00ffff', backgroundColor: 'rgba(0,255,255,0.04)' } ]},
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { y: { display: false, grid: { display: false }, ticks: { display: false } }, x: { grid: { color: 'rgba(255,255,255,0.03)' } } }
                        }
                    });
                }
            }catch(e){ console.warn('Chart init skipped or failed (no canvas?):', e); }
        }

        // Helper: try loading an image several times with a short delay (cache-busted)
        async function loadImageWithRetry(basePath, imgEl, attempts=6, delayMs=400){
            for(let i=0;i<attempts;i++){
                const cb = '?v=' + Date.now();
                const url = buildUrl(basePath) + cb;
                const ok = await new Promise((resolve)=>{
                    const t = new Image();
                    t.onload = ()=> resolve(true);
                    t.onerror = ()=> resolve(false);
                    t.src = url;
                });
                if(ok){ imgEl.src = url; imgEl.style.display = 'block'; return true; }
                // wait before retry
                await new Promise(r=>setTimeout(r, delayMs));
            }
            imgEl.style.display = 'none';
            return false;
        }

        async function fetchCSVNumbers(url){
            try{
                const res = await fetch(buildUrl(url));
                if(!res.ok) throw new Error('not found');
                const txt = await res.text();
                const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
                const values = [];
                for(const line of lines){
                    const cols = line.split(',').map(c=>c.trim());
                    // find first numeric column from left
                    let found = null;
                    for(const c of cols){
                        const m = c.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/);
                        if(m){ found = Number(m[0]); break; }
                    }
                    if(found !== null) values.push(found);
                }
                return values;
            }catch(e){ return null; }
        }

        // juyo CSV を読み、[{label: 'YYYY/M/D H:MM', value: number}, ...] を返す
        async function fetchJuyoData(year){
            const url = buildUrl(`/data/juyo-${year}.csv`);
            try{
                const res = await fetch(url);
                if(!res.ok) return null;
                const txt = await res.text();
                const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
                const rows = [];
                for(const line of lines){
                    // data lines look like: 2019/1/1,0:00,3017
                    const m = line.match(/^(\d{4}\/\d{1,2}\/\d{1,2}),\s*(\d{1,2}:\d{2}),\s*([0-9\.]+)$/);
                    if(m){ rows.push({label: `${m[1]} ${m[2]}`, value: Number(m[3])}); }
                }
                return rows;
            }catch(e){ return null; }
        }

        // --- Metric utilities: compute RMSE, R2, MAE on the client from actuals and preds ---
        function computeMetrics(actuals, preds){
            if(!actuals || !preds) return {rmse:null, r2:null, mae:null};
            const n = Math.min(actuals.length, preds.length);
            if(n === 0) return {rmse:null, r2:null, mae:null};
            let ssRes = 0.0, ssTot = 0.0, sumActual = 0.0, sumAbs = 0.0;
            for(let i=0;i<n;i++) sumActual += actuals[i];
            const meanActual = sumActual / n;
            for(let i=0;i<n;i++){
                const a = actuals[i];
                const p = preds[i];
                const err = a - p;
                ssRes += err*err;
                ssTot += (a - meanActual)*(a - meanActual);
                sumAbs += Math.abs(err);
            }
            const mse = ssRes / n;
            const rmse = Math.sqrt(mse);
            const mae = sumAbs / n;
            const r2 = (ssTot === 0) ? 0 : (1 - ssRes/ssTot);
            return { rmse: rmse, r2: r2, mae: mae };
        }

        async function updateTrainMetrics(model){
            try{
                // 学習時のテストデータ(data/Ytest.csv)から実測値を取得
                // 注意: juyo CSVの全データではなく、data.pyで分割されたテストデータを使用
                const actualPath = buildUrl('/data/Ytest.csv');
                const predPath = buildUrl(`/train/${model}/${model}_Ypred.csv`);
                
                // if prediction CSV not present, clear train metrics to avoid stale values
                try{
                    const chk = await fetch(predPath);
                    if(!chk.ok){ ['trainRmse','trainR2','trainMae','trainModelName'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='-'; }); return; }
                }catch(e){ ['trainRmse','trainR2','trainMae','trainModelName'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='-'; }); return; }
                
                // 実測値と予測値を取得
                const actuals = await fetchCSVNumbers(actualPath) || [];
                const preds = await fetchCSVNumbers(predPath) || [];
                
                // 指標を計算
                const metrics = computeMetrics(actuals, preds);
                if(metrics.rmse !== null) document.getElementById('trainRmse').textContent = metrics.rmse.toFixed(2);
                if(metrics.r2 !== null) document.getElementById('trainR2').textContent = metrics.r2.toFixed(3);
                if(metrics.mae !== null) document.getElementById('trainMae').textContent = metrics.mae.toFixed(3);
                const tname = document.getElementById('trainModelName'); if(tname) tname.textContent = model;
            }catch(e){ console.warn('updateTrainMetrics failed', e); }
        }

        async function updatePredMetrics(model){
            try{
                const predPath = buildUrl(`/tomorrow/${model}/${model}_tomorrow.csv`);
                const actualPath = buildUrl('/tomorrow/Ytest.csv');
                // ensure pred CSV exists; if not, clear pred metrics to avoid stale display
                try{
                    const chk = await fetch(predPath);
                    if(!chk.ok){ ['predRmse','predR2','predMae','predModelName'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='-'; }); return; }
                }catch(e){ ['predRmse','predR2','predMae','predModelName'].forEach(id=>{ const el=document.getElementById(id); if(el) el.textContent='-'; }); return; }
                const preds = await fetchCSVNumbers(predPath) || [];
                const actuals = await fetchCSVNumbers(actualPath) || [];
                // align to same length from start
                const metrics = computeMetrics(actuals.slice(0, preds.length), preds.slice(0, preds.length));
                if(metrics.rmse !== null) document.getElementById('predRmse').textContent = metrics.rmse.toFixed(2);
                if(metrics.r2 !== null) document.getElementById('predR2').textContent = metrics.r2.toFixed(3);
                if(metrics.mae !== null) document.getElementById('predMae').textContent = metrics.mae.toFixed(3);
                const pname = document.getElementById('predModelName'); if(pname) pname.textContent = model;
            }catch(e){ console.warn('updatePredMetrics failed', e); }
        }

        async function loadTrainChart(model){
            createCharts();
            // 表示する学習モデル名を確実にセット
            const tname = document.getElementById('trainModelName'); if(tname) tname.textContent = model;
            // Prefer to show pre-rendered PNG if it exists (use Image onload/onerror)
            const trainImg = document.getElementById('trainImage');
            const imgPath = buildUrl(`/train/${model}/${model}_Ypred.png`);
            // try to load with retries to avoid race where script returns before file written
            await loadImageWithRetry(imgPath, trainImg, 6, 400);

            // 学習時のテストデータ(data/Ytest.csv)から実測値を取得
            // 注意: juyo CSVの全データではなく、data.pyで分割されたテストデータを使用
            const actualPath = buildUrl('/data/Ytest.csv');
            const predPath = buildUrl(`/train/${model}/${model}_Ypred.csv`);
            
            const actuals = await fetchCSVNumbers(actualPath) || [];
            const preds = await fetchCSVNumbers(predPath) || [];
            
            // ラベルは単純なインデックスで生成（時系列データのため）
            const labels = [];
            const dataLength = Math.max(actuals.length, preds.length);
            for(let i = 0; i < dataLength; i++) {
                labels.push(`t+${i}`);
            }

            if(trainChartObj){
                trainChartObj.data.labels = labels;
                trainChartObj.data.datasets[0].data = preds;
                if(trainChartObj.data.datasets.length < 2){
                    trainChartObj.data.datasets.push({ label: 'Actual', data: actuals, borderColor: '#00ffff', backgroundColor: 'rgba(0,255,255,0.04)' });
                } else {
                    trainChartObj.data.datasets[1].data = actuals;
                }
                trainChartObj.update();
            }
        }

        async function loadPredChart(model){
            createCharts();
            // 表示する予測モデル名を確実にセット
            const pname = document.getElementById('predModelName'); if(pname) pname.textContent = model;
            // Prefer to show pre-rendered PNG for predictions
            const predImg = document.getElementById('predImage');
            const predImgPath = buildUrl(`/tomorrow/${model}/${model}_tomorrow.png`);
            await loadImageWithRetry(predImgPath, predImg, 6, 400);
            const predPath = buildUrl(`/tomorrow/${model}/${model}_tomorrow.csv`);
            const actualPath = buildUrl('/tomorrow/Ytest.csv');
            const pvals = await fetchCSVNumbers(predPath);
            const avals = await fetchCSVNumbers(actualPath);
            // show past 7 days actuals (7*24 = 168) if available
            const PAST = 7*24;
            const pastActuals = (avals && avals.length>0) ? avals.slice(-PAST) : [];
            const predVals = pvals || [];

            // labels: past hours then prediction hours
            const labels = [];
            for(let i=0;i<pastActuals.length;i++) labels.push(`t-${pastActuals.length-i}`);
            for(let i=0;i<predVals.length;i++) labels.push(`pred+${i+1}`);

            if(predChartObj){
                predChartObj.data.labels = labels;
                predChartObj.data.datasets[0].data = predVals.length ? Array(pastActuals.length).fill(null).concat(predVals) : Array(labels.length).fill(null);
                predChartObj.data.datasets[1].data = pastActuals.concat(Array(Math.max(0, predVals.length - 0)).fill(null));
                predChartObj.update();
            }
        }

        // 初期チャート描画（空）
        createCharts();

    // Ensure legends are hidden even if Chart.js default differs
    if(trainChartObj){ trainChartObj.options = trainChartObj.options || {}; trainChartObj.options.plugins = trainChartObj.options.plugins || {}; trainChartObj.options.plugins.legend = { display: false }; trainChartObj.update(); }
    if(predChartObj){ predChartObj.options = predChartObj.options || {}; predChartObj.options.plugins = predChartObj.options.plugins || {}; predChartObj.options.plugins.legend = { display: false }; predChartObj.update(); }

        // --- Modal for enlarged PNG handling ---
        // create modal elements (already in DOM appended below)
        const modalOverlay = document.getElementById('imgModal');
        const modalImg = document.getElementById('imgModalImg');
        const modalClose = document.getElementById('imgModalClose');

        let _lastFocusedElement = null;
        function openImageModal(src){
            if(!src) return;
            _lastFocusedElement = document.activeElement;
            modalImg.src = src;
            modalOverlay.classList.add('show');
            document.body.style.overflow = 'hidden';
            document.body.classList.add('modal-open');
            // focus the modal download button for keyboard users
            const md = document.getElementById('modalDownload');
            if(md) md.focus();
        }
        function closeImageModal(){
            modalOverlay.classList.remove('show');
            modalImg.src = '';
            document.body.style.overflow = '';
            document.body.classList.remove('modal-open');
            // restore focus
            try{ if(_lastFocusedElement && typeof _lastFocusedElement.focus === 'function') _lastFocusedElement.focus(); }catch(e){}
            _lastFocusedElement = null;
        }

        // Delegate clicks on images to document to ensure handlers work even if elements are swapped dynamically
        document.addEventListener('click', (e)=>{
            const t = e.target;
            if(!t) return;
            // train image clicked
                if(t.id === 'trainImage'){
                e.stopPropagation();
                const src = t.getAttribute('src') || '';
                if(src && src.trim() && t.style.display !== 'none') return openImageModal(src);
                const expected = buildUrl(`/train/${selectedModel}/${selectedModel}_Ypred.png`);
                const tmp = new Image(); tmp.onload = ()=> openImageModal(expected); tmp.onerror = ()=>{}; tmp.src = expected;
                return;
            }
            // pred image clicked
            if(t.id === 'predImage'){
                e.stopPropagation();
                const src = t.getAttribute('src') || '';
                if(src && src.trim() && t.style.display !== 'none') return openImageModal(src);
                const expected = buildUrl(`/tomorrow/${selectedModel}/${selectedModel}_tomorrow.png`);
                const tmp2 = new Image(); tmp2.onload = ()=> openImageModal(expected); tmp2.onerror = ()=>{}; tmp2.src = expected;
                return;
            }
        });

        // Chart wrapper click/keyboard -> open modal (pre-click tooltip instructs user)
        const predWrapper = document.getElementById('predChartWrapper');
        const trainWrapper = document.getElementById('trainChartWrapper');
        if(predWrapper){
            predWrapper.addEventListener('click', (e)=>{
                // prefer showing image src if loaded
                const img = document.getElementById('predImage');
                const src = img && img.getAttribute('src') ? img.getAttribute('src') : buildUrl(`/tomorrow/${selectedModel}/${selectedModel}_tomorrow.png`);
                openImageModal(src);
            });
            predWrapper.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); predWrapper.click(); } });
        }
        if(trainWrapper){
            trainWrapper.addEventListener('click', (e)=>{
                const img = document.getElementById('trainImage');
                const src = img && img.getAttribute('src') ? img.getAttribute('src') : buildUrl(`/train/${selectedModel}/${selectedModel}_Ypred.png`);
                openImageModal(src);
            });
            trainWrapper.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); trainWrapper.click(); } });
        }

        // Note: Chart.js canvases removed; canvas click handlers are no longer necessary.

        // overlay click to close (but clicking the image itself should not close)
        modalOverlay.addEventListener('click', (e)=>{ if(e.target === modalOverlay) closeImageModal(); });
        modalClose.addEventListener('click', closeImageModal);
        // ESC to close
        document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeImageModal(); });

        // Modal image interaction: zoom, wheel zoom, dblclick reset, fullscreen
        const modalZoomIn = document.getElementById('modalZoomIn');
        const modalZoomOut = document.getElementById('modalZoomOut');
        const modalFullscreen = document.getElementById('modalFullscreen');
        let modalScale = 1;
        function applyModalTransform(){ modalImg.style.transform = `scale(${modalScale})`; }
        modalZoomIn.addEventListener('click', ()=>{ modalScale = Math.min(4, modalScale + 0.25); applyModalTransform(); });
        modalZoomOut.addEventListener('click', ()=>{ modalScale = Math.max(0.25, modalScale - 0.25); applyModalTransform(); });
        modalImg.addEventListener('wheel', (ev)=>{
            ev.preventDefault();
            const delta = ev.deltaY > 0 ? -0.15 : 0.15;
            modalScale = Math.min(6, Math.max(0.25, modalScale + delta));
            applyModalTransform();
        }, { passive:false });
        modalImg.addEventListener('dblclick', ()=>{ modalScale = 1; applyModalTransform(); });
        modalFullscreen.addEventListener('click', async ()=>{
            try{
                if(!document.fullscreenElement){
                    await modalOverlay.requestFullscreen();
                } else { await document.exitFullscreen(); }
            }catch(e){ console.warn('fullscreen failed', e); }
        });

        // ダウンロードボタン: モーダルに表示されている画像を取得して保存
        const modalDownload = document.getElementById('modalDownload');
        // Allow click and keyboard activation (Enter/Space) for accessibility
        const modalDownloadHandler = async ()=>{
            try{
                const src = modalImg.getAttribute('src');
                if(!src) return alert('ダウンロードする画像がありません');

                // fetch the image as blob (avoid CORS issues with same-origin files served by our server)
                const resp = await fetch(src);
                if(!resp.ok) throw new Error('画像取得に失敗しました');
                const blob = await resp.blob();

                // Create a temporary anchor to trigger download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                // derive filename from src
                const parts = src.split('/');
                let filename = parts[parts.length-1].split('?')[0] || 'download.png';
                // Ensure filename has extension
                if(!filename.match(/\.[a-zA-Z]{2,4}$/)) filename += '.png';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
            }catch(err){
                console.warn('download failed', err);
                alert('ダウンロードに失敗しました: ' + err.message);
            }
        };
        modalDownload.addEventListener('click', modalDownloadHandler);
        modalDownload.addEventListener('keydown', async (e)=>{
            if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); await modalDownloadHandler(); }
        });


    </script>
</body>
</html>
