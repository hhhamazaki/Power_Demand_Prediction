<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アンモニア在庫レベル予測ダッシュボード</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: auto;
            color-scheme: dark;
        }
        .container {
            max-width: 1600px;
            width: 100%;
            min-height: 900px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.1);
        }
        .header { text-align: center; margin-bottom: 30px; }
        .title {
            font-size: 2.5rem; font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #00ff88, #ff00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        .control-panel {
            display: grid; grid-template-columns: 1.2fr 1.6fr 0.8fr 0.8fr;
            gap: 20px; margin-bottom: 30px; align-items: stretch;
        }
        .control-group {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px; padding: 20px; text-align: center;
            display: flex; flex-direction: column; /* For vertical alignment */
            transition: background 0.5s, border-color 0.5s;
        }
        .control-group h3 { color: #00ffff; margin-bottom: 15px; font-size: 1.1rem; }
        .refill-level-control {
            display: flex; align-items: center; justify-content: center;
            gap: 10px;
        }
        .btn {
            background: linear-gradient(45deg, #00ffff, #00ff88);
            border: none; color: #000; padding: 8px 15px; border-radius: 5px;
            cursor: pointer; font-weight: bold; transition: all 0.3s ease; font-size: 0.9rem;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4); }
        .input-field {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #e0e0e0; padding: 8px 12px; border-radius: 5px; width: 80px;
            text-align: center; font-size: 1rem;
        }
        .input-field:focus { outline: none; border-color: #00ffff; box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
        .input-field::-webkit-outer-spin-button,
        .input-field::-webkit-inner-spin-button {
            -webkit-appearance: inner-spin-button;
            opacity: 1;
        }
        .date-control { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .date-input {
            background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(0, 255, 255, 0.3);
            color: #e0e0e0; padding: 10px; border-radius: 5px; font-size: 1rem;
        }
        .nav-btn {
            background: linear-gradient(45deg, #ff00ff, #8a2be2);
            border: none; color: white; padding: 8px 12px; border-radius: 5px;
            cursor: pointer; font-weight: bold; transition: all 0.3s ease; font-size: 0.9rem;
        }
        .nav-btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(255, 0, 255, 0.4); }
        
        .date-input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            margin-bottom: 15px;
        }
        .date-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .month-buttons {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            justify-content: center;
        }
        .month-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff; padding: 5px 10px; border-radius: 5px;
            cursor: pointer; transition: all 0.3s ease; font-size: 0.8rem;
        }
        .month-btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .chart-container {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 15px; padding: 20px; margin-bottom: 20px;
            height: 500px; position: relative;
        }
        
        #warningContainer.is-warning {
            background: rgba(255, 0, 255, 0.1);
            border-color: rgba(255, 0, 255, 0.3);
            animation: pulse 2s infinite;
        }
        #warningContainer.is-warning .warning-title {
            color: #ff00ff;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 0, 255, 0.5); }
        }
        .warning-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 10px; transition: color 0.5s; }
        .warning-text { color: #e0e0e0; font-size: 1rem; text-align: left; }

        .stats-panel {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px; margin-top: 20px;
        }
        .stat-card {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px; padding: 15px; text-align: center;
        }
        .stat-title { color: #00ffff; font-size: 0.9rem; margin-bottom: 5px; }
        .stat-value { color: #fff; font-size: 1.5rem; font-weight: bold; }
        .loading { text-align: center; color: #00ffff; font-size: 1.2rem; padding: 50px; }
        @media (max-width: 1200px) {
            .container { max-width: 95%; min-height: auto; }
            .control-panel { grid-template-columns: 1fr; gap: 15px; }
            .title { font-size: 2rem; }
        }
        @media (max-width: 768px) {
            .container { padding: 15px; }
            .title { font-size: 1.5rem; }
            .date-input-group { flex-wrap: wrap; }
            .chart-container { height: 400px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">アンモニア在庫レベル予測ダッシュボード（データ連携ライブ版デモ用アプリ）</h1>
        </div>

        <div class="control-panel">
            <div class="control-group" id="warningContainer">
                <h3 class="warning-title" id="warningTitle"></h3>
                <div class="warning-text" id="warningText"></div>
            </div>

            <div class="control-group">
                <h3>基準日選択</h3>
                <div class="date-control">
                    <div class="date-input-group">
                        <button class="nav-btn" onclick="navigateDate(-7)">-7日</button>
                        <button class="nav-btn" onclick="navigateDate(-1)">-1日</button>
                        <div class="date-input-container">
                            <input type="date" id="baseDate" class="date-input" onchange="updateChart()">

                        </div>
                        <button class="nav-btn" onclick="navigateDate(1)">+1日</button>
                        <button class="nav-btn" onclick="navigateDate(7)">+7日</button>
                    </div>
                    <div class="month-buttons" id="monthButtons">
                        <!-- 年月ボタンはCSVデータ期間に基づき自動生成 -->
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>補充レベル設定 [m³]</h3>
                <div class="refill-level-control">
                    <button class="btn" onclick="adjustRefillLevel(-10)">-10</button>
                    <input type="number" id="refillLevel" class="input-field" value="600" min="0" max="1000" onchange="updateChart()">
                    <button class="btn" onclick="adjustRefillLevel(10)">+10</button>
                </div>
            </div>

            <div class="control-group">
                <h3>アンサンブル処理</h3>
                <p style="font-size: 0.8rem; color: #a0a0a0; margin-bottom: 10px; text-align: center;">
                    RandomForest + GradientBoosting + Ridge回帰
                </p>
                <div class="refill-level-control" style="flex-direction: column; gap: 15px; justify-content: center; flex-grow: 1;">
                    <button class="btn" onclick="runTrain(event)" style="width: 120px;">学習</button>
                    <button class="btn" onclick="runPredict(event)" style="width: 120px;">予測</button>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-title">基準日の在庫レベル</div>
                <div class="stat-value" id="currentStock">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">予測精度 (R²)</div>
                <div class="stat-value" id="accuracy">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">平均予測誤差</div>
                <div class="stat-value" id="avgError">-</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">次回補充推奨</div>
                <div class="stat-value" id="nextRefill">-</div>
            </div>
        </div>
    </div>




    <script>
        let chartData = [];
        let chart = null;
        let currentRange = 30;


        // CSVファイルの読み込み
        function loadCsvFile() {
            fetch('../data/predictions.csv')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`CSVファイルの読み込みに失敗: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    parseCsvData(csvText);
                })
                .catch(error => {
                    showErrorMessage(error);
                    console.error('CSVファイル読み込みエラー:', error);
                });
        }

        // CSVデータの解析
        function parseCsvData(csvText) {
            if (!csvText) {
                showErrorMessage(new Error('CSVファイルが空です'));
                return;
            }

            const lines = csvText.split('\n').filter(Boolean);
            if (lines.length < 2) {
                showErrorMessage(new Error('CSVにデータが不足しています'));
                return;
            }

            const headers = lines[0].split(',').map(h => h.trim());
            const requiredColumns = ['date', 'actual_ammonia', 'predicted_ammonia'];
            const missing = requiredColumns.filter(c => !headers.includes(c));
            if (missing.length > 0) {
                showErrorMessage(new Error(`必要な列が見つかりません: ${missing.join(', ')}`));
                return;
            }

            chartData = [];
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i];
                if (!row.trim()) continue;
                const values = row.split(',').map(v => v.trim());
                const obj = {};
                headers.forEach((h, idx) => { obj[h] = values[idx] ?? ''; });
                if (obj.date && !isNaN(Date.parse(obj.date))) {
                    chartData.push(obj);
                }
            }

            if (chartData.length === 0) {
                showErrorMessage(new Error('有効なデータが見つかりませんでした'));
                return;
            }

            chartData.sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // CSVデータ期間に基づく基準値選択ボタンを自動生成
            generateDateButtons();
            
            const middleIndex = Math.floor(chartData.length / 2);
            const baseInput = document.getElementById('baseDate');
            baseInput.value = chartData[middleIndex].date;

            updateChart();
            updateSummary();
            updateDataTable();
            
            console.log('CSVデータ読み込み完了:', chartData.length, '行')
            // exists in the chartData, use it. Otherwise, pick the closest
            // available date (prefer latest past date, then earliest future).
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            const dates = chartData.map(d => d.date);
            if (dates.includes(todayStr)) {
                baseInput.value = todayStr;
            } else {
                // find the closest date <= today, prefer the latest past date
                const pastDates = dates.filter(d => new Date(d) <= today).sort((a,b) => new Date(b) - new Date(a));
                if (pastDates.length > 0) {
                    baseInput.value = pastDates[0];
                } else {
                    // no past dates, use the earliest available
                    baseInput.value = dates[0];
                }
            }

            updateChart();
        }

        // Try to load external CSV from data/predictions.csv; if fails, fall back to embedded CSV
        async function loadCsvFromDataFile() {
            const dataPath = '../data/predictions.csv';
            try {
                const res = await fetch(dataPath, { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const csvText = (await res.text()).replace(/\r\n/g, '\n').trim();
                if (!csvText) throw new Error('Empty CSV');

                // parse same as embedded loader
                const lines = csvText.split('\n').filter(Boolean);
                if (lines.length < 2) throw new Error('CSV has insufficient rows');
                const headers = lines[0].split(',').map(h => h.trim());
                const requiredColumns = ['date', 'actual_ammonia', 'predicted_ammonia'];
                const missing = requiredColumns.filter(c => !headers.includes(c));
                if (missing.length > 0) throw new Error(`Missing columns: ${missing.join(',')}`);

                chartData = [];
                for (let i = 1; i < lines.length; i++) {
                    const row = lines[i];
                    if (!row.trim()) continue;
                    const values = row.split(',').map(v => v.trim());
                    const obj = {};
                    headers.forEach((h, idx) => { obj[h] = values[idx] ?? ''; });
                    if (obj.date && !isNaN(Date.parse(obj.date))) {
                        chartData.push(obj);
                    }
                }

                if (chartData.length === 0) throw new Error('No valid data in CSV');

                chartData.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                // CSVデータ期間に基づく基準値選択ボタンを自動生成
                generateDateButtons();
                
                // 基準日を今日（2025年10月6日）に設定
                const today = new Date();
                const todayStr = today.toISOString().split('T')[0];
                const baseInput = document.getElementById('baseDate');
                
                // 今日の日付がデータ範囲内にあるかチェック
                const dates = chartData.map(d => d.date);
                const dataStartDate = new Date(dates[0]);
                const dataEndDate = new Date(dates[dates.length - 1]);
                const todayDate = new Date(todayStr);
                
                if (todayDate >= dataStartDate && todayDate <= dataEndDate) {
                    baseInput.value = todayStr;
                } else {
                    // 今日がデータ範囲外の場合は中間値を使用
                    const middleIndex = Math.floor(chartData.length / 2);
                    baseInput.value = chartData[middleIndex].date;
                }

                updateChart();
            } catch (err) {
                // Fall back to embedded CSV
                loadCsvFile();
            }
        }

        // CSVデータ期間に基づく基準値選択ボタンを自動生成
        function generateDateButtons() {
            if (chartData.length === 0) return;
            
            const monthButtons = document.getElementById('monthButtons');
            if (!monthButtons) return;
            
            // 月単位でグループ化
            const months = new Set();
            chartData.forEach(item => {
                const date = new Date(item.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.add(monthKey);
            });
            
            // ボタンを生成
            monthButtons.innerHTML = '';
            Array.from(months).sort().forEach(monthKey => {
                const [year, month] = monthKey.split('-');
                const shortYear = year.slice(-2);
                const button = document.createElement('button');
                button.className = 'month-btn';
                button.textContent = `${shortYear}/${month}`;
                button.onclick = () => setBaseDate(`${year}-${month}-01`);
                monthButtons.appendChild(button);
            });
        }

        function showErrorMessage(error) {
            const errorHtml = `
                <div class="loading" style="text-align: left; padding: 30px;">
                    <h3 style="color: #ff00ff; margin-bottom: 20px;">⚠️ データ読み込みエラー</h3>
                    <p style="color: #e0e0e0; margin-bottom: 15px;"><strong>エラー詳細:</strong> ${error.message}</p>
                    <div style="color: #a0a0a0; font-size: 0.9rem;">
                        <p><strong>確認事項:</strong></p>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>predictions.csvファイルが存在し、正しい形式であるか</li>
                            <li>ヘッダーが「date, actual_power, actual_ammonia, is_refill, predicted_ammonia, prediction_error, prediction_error_pct」になっているか</li>
                        </ul>
                    </div>
                </div>
            `;
            document.querySelector('.chart-container').innerHTML = errorHtml;
        }

        // 補充レベル調整
        function adjustRefillLevel(amount) {
            const input = document.getElementById('refillLevel');
            const newValue = parseInt(input.value, 10) + amount;
            if (newValue >= 0 && newValue <= 1000) {
                input.value = String(newValue);
                updateChart();
            }
        }

        // 日付ナビゲーション
        function navigateDate(days) {
            const dateInput = document.getElementById('baseDate');
            const currentDate = new Date(dateInput.value);
            currentDate.setDate(currentDate.getDate() + days);
            dateInput.value = currentDate.toISOString().split('T')[0];
            updateChart();
        }

        function setBaseDate(dateStr) {
            const dateInput = document.getElementById('baseDate');
            dateInput.value = dateStr;
            updateChart();
        }

        // チャート更新
        function updateChart() {
            if (chartData.length === 0) {
                return;
            }

            const baseDateStr = document.getElementById('baseDate').value;
            if (!baseDateStr) {
                return;
            }
            const baseDate = new Date(baseDateStr);


            const minDate = new Date('2024-10-01');
            // Determine maxDate from the last row in the loaded chartData (assumes chartData is sorted ascending)
            const maxDate = new Date(chartData[chartData.length - 1].date);
            if (baseDate < minDate || baseDate > maxDate) {
                return;
            }

            const refillLevel = parseInt(document.getElementById('refillLevel').value, 10);

            const startDate = new Date(baseDate);
            startDate.setDate(startDate.getDate() - currentRange);
            const endDate = new Date(baseDate);
            endDate.setDate(endDate.getDate() + currentRange);

            const filteredData = chartData.filter(item => {
                const d = new Date(item.date);
                return d >= startDate && d <= endDate;
            });

            if (filteredData.length === 0) {
                if (chart) chart.destroy();
                const ctx = document.getElementById('mainChart').getContext('2d');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                return;
            }

            const labels = filteredData.map(item => {
                const d = new Date(item.date);
                return `${d.getMonth() + 1}/${d.getDate()}`;
            });
            const actualAmmoniaData = filteredData.map(item => {
                const val = parseFloat(item.actual_ammonia);
                return (!isNaN(val) && item.actual_ammonia !== '') ? val : null;
            });
            const predictedAmmoniaData = filteredData.map(item => parseFloat(item.predicted_ammonia) || 0);
            const actualPowerData = filteredData.map(item => parseFloat(item.actual_power) || 0);
            const refillLevelData = new Array(labels.length).fill(refillLevel);

            if (chart) chart.destroy();
            const ctx = document.getElementById('mainChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: '実績在庫 (m³)', data: actualAmmoniaData, borderColor: '#00ffff', backgroundColor: 'rgba(0, 255, 255, 0.1)', borderWidth: 3, tension: 0.4, yAxisID: 'y', spanGaps: false },
                        { label: '予測在庫 (m³)', data: predictedAmmoniaData, borderColor: '#00ff88', backgroundColor: 'rgba(0, 255, 136, 0.1)', borderWidth: 2, borderDash: [5,5], tension: 0.4, yAxisID: 'y', pointRadius: 0 },
                        { label: '補充レベル (m³)', data: refillLevelData, borderColor: '#ff00ff', backgroundColor: 'rgba(255, 0, 255, 0.1)', borderWidth: 2, borderDash: [10,5], tension: 0, yAxisID: 'y', pointRadius: 0 },
                        { label: '発電実績 (kW)', data: actualPowerData, borderColor: '#ffaa00', backgroundColor: 'rgba(255,170,0,0.1)', borderWidth: 1, tension: 0.4, yAxisID: 'y1' }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { labels: { color: '#e0e0e0', font: { size: 12 } } },
                        tooltip: { backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#00ffff', bodyColor: '#e0e0e0', borderColor: '#00ffff', borderWidth: 1 }
                    },
                    scales: {
                        x: {
                            grid: { color: 'rgba(0,255,255,0.1)' },
                            ticks: {
                                color: (context) => {
                                    const baseDateLabel = `${baseDate.getMonth() + 1}/${baseDate.getDate()}`;
                                    const currentLabel = context.chart.data.labels[context.index];
                                    return currentLabel === baseDateLabel ? 'red' : '#e0e0e0';
                                },
                                callback: function(value, index, ticks) {
                                    const label = this.getLabelForValue(value);
                                    const baseDateLabel = `${baseDate.getMonth() + 1}/${baseDate.getDate()}`;
                                    if (label === baseDateLabel) {
                                        return ['基準日', label];
                                    }
                                    return label;
                                }
                            }
                        },
                        y: { type: 'linear', display: true, position: 'left', title: { display: true, text: '在庫レベル (m³)', color: '#00ffff' }, grid: { drawOnChartArea: false }, ticks: { color: '#e0e0e0' } },
                        y1: { type: 'linear', display: true, position: 'right', title: { display: true, text: '発電量 (kW)', color: '#ffaa00' }, grid: { drawOnChartArea: false }, ticks: { color: '#e0e0e0' } }
                    }
                },
                plugins: [{
                    id: 'baseDateLine',
                    afterDraw: (chart) => {
                        const baseDateLabel = `${baseDate.getMonth() + 1}/${baseDate.getDate()}`;
                        const index = chart.data.labels.indexOf(baseDateLabel);
                        if (index === -1) return;

                        const ctx = chart.ctx;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const x = xAxis.getPixelForValue(index);

                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.restore();
                    }
                }]
            });

            checkRefillWarning(filteredData, refillLevel, baseDate);
            updateStats(filteredData, baseDate);
        }

        // 補充警告
        function checkRefillWarning(data, refillLevel, baseDate) {
            const warningContainer = document.getElementById('warningContainer');
            const warningTitle = document.getElementById('warningTitle');
            const warningText = document.getElementById('warningText');
            const futureData = data.filter(item => new Date(item.date) >= baseDate);
            const warningDays = [];

            for (const item of futureData) {
                const predictedLevel = parseFloat(item.predicted_ammonia) || 0;
                if (predictedLevel < refillLevel) {
                    const daysFromBase = Math.ceil((new Date(item.date) - baseDate) / (1000*60*60*24));
                    warningDays.push({ days: daysFromBase, level: predictedLevel, date: item.date });
                }
            }

            if (warningDays.length > 0) {
                const nearestWarning = warningDays[0];
                warningTitle.innerHTML = `⚠️ 補充警告`;
                warningText.innerHTML = `
                    ${nearestWarning.days}日後（${nearestWarning.date}）に在庫レベルが補充レベル（${refillLevel} m³）を下回る予測です。<br>
                    予測在庫レベル: ${nearestWarning.level.toFixed(1)} m³
                `;
                warningContainer.classList.add('is-warning');
            } else {
                warningTitle.innerHTML = `✅ 警告なし`;
                warningText.innerHTML = '予測期間内に補充レベルを下回る予測はありません。';
                warningContainer.classList.remove('is-warning');
            }
        }

        // 統計
        function updateStats(data, baseDate) {
            if (data.length === 0) return;
            const baseData = data.find(item => item.date === baseDate.toISOString().split('T')[0]);
            const currentStock = baseData ? parseFloat(baseData.actual_ammonia) : 0;
            document.getElementById('currentStock').textContent = `${currentStock.toFixed(1)} m³`;

            const actualValues = data.map(item => parseFloat(item.actual_ammonia) || 0);
            const predictedValues = data.map(item => parseFloat(item.predicted_ammonia) || 0);
            const r2 = calculateR2(actualValues, predictedValues);
            document.getElementById('accuracy').textContent = `${(r2 * 100).toFixed(1)}%`;

            const errors = data.map(item => Math.abs(parseFloat(item.prediction_error) || 0));
            const avgError = errors.reduce((s, e) => s + e, 0) / errors.length;
            document.getElementById('avgError').textContent = `${avgError.toFixed(1)} m³`;

            // 次回補充推奨（予測値ベース）
            const refillLevel = parseInt(document.getElementById('refillLevel').value, 10);
            const futureData = data.filter(item => new Date(item.date) > baseDate);
            
            if (futureData.length > 0) {
                // 予測値が補充レベルを下回る最初の日を検索
                const nextRefillPrediction = futureData.find(item => 
                    parseFloat(item.predicted_ammonia) <= refillLevel
                );
                
                if (nextRefillPrediction) {
                    const nextRefillDate = new Date(nextRefillPrediction.date);
                    const daysUntilRefill = Math.ceil((nextRefillDate - baseDate) / (1000 * 60 * 60 * 24));
                    const formattedDate = nextRefillDate.toLocaleDateString('ja-JP', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });
                    document.getElementById('nextRefill').textContent = `${formattedDate}（${daysUntilRefill}日後）`;
                } else {
                    // is_refillフラグによる補充予定を確認
                    const futureRefills = futureData.filter(item =>
                        parseInt(item.is_refill, 10) === 1
                    );
                    if (futureRefills.length > 0) {
                        const nextRefillDate = new Date(futureRefills[0].date);
                        const daysUntilRefill = Math.ceil((nextRefillDate - baseDate) / (1000 * 60 * 60 * 24));
                        const formattedDate = nextRefillDate.toLocaleDateString('ja-JP', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit'
                        });
                        document.getElementById('nextRefill').textContent = `${formattedDate}（${daysUntilRefill}日後）`;
                    } else {
                        document.getElementById('nextRefill').textContent = '予測期間内になし';
                    }
                }
            } else {
                document.getElementById('nextRefill').textContent = '予測データなし';
            }
        }

        function calculateR2(actual, predicted) {
            if (actual.length !== predicted.length || actual.length === 0) return 0;
            const mean = actual.reduce((s, v) => s + v, 0) / actual.length;
            const ssTot = actual.reduce((s, v) => s + Math.pow(v - mean, 2), 0);
            const ssRes = actual.reduce((s, v, i) => s + Math.pow(v - predicted[i], 2), 0);
            return ssTot === 0 ? 0 : 1 - (ssRes / ssTot);
        }

        async function runProcess(endpoint, processName, button) {
            const originalText = button.textContent;
            button.textContent = '実行中...';
            button.disabled = true;

            try {
                // Use a same-origin relative path to avoid relying on window.location.origin
                // which can be undefined or point to the wrong port in some cases.
                const response = await fetch(`/${endpoint}`, {
                    method: 'POST',
                });

                const result = await response.json();

                if (response.ok) {
                    alert(`'${processName}' が完了しました。ページをリロードして結果を確認してください。

サーバー出力:
${result.output}`);
                } else {
                    alert(`'${processName}' でエラーが発生しました。

エラー:
${result.output || result.message}`);
                }
            } catch (error) {
                alert(`サーバーとの通信に失敗しました。ローカルサーバーが起動していることを確認してください。

${error}`);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        function runTrain(event) {
            runProcess('run-train', '学習', event.target);
        }

        function runPredict(event) {
            runProcess('run-predict', '予測', event.target);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Try to load external CSV first; fall back to embedded CSV if unavailable
            loadCsvFromDataFile();
        });
    </script>
</body>
</html>