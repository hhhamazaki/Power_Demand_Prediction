# 電力需要予測AIモデル構築 - プロジェクト計画書 v2.0

※ この資料は教育用のサンプルです。

**バージョン**: v2.0  
**リリース日**: 2025年10月15日  
**主要特性**: CLI + Webダッシュボード統合版

---

## 1. 目的・背景

### 1.1. 目的・背景
電力需要予測の精度向上とエネルギー管理最適化を目的とした、機械学習を活用した包括的な予測システムの構築である。4つの異なる機械学習アルゴリズム（Keras、LightGBM、PyCaret、RandomForest）を用いたアンサンブル予測システムに加え、**Webダッシュボード統合**により操作性を劇的に改善し、電力需要の短期・中期予測精度の最大化と運用効率化を実現する。

本プロジェクトは、過去の電力消費量データに基づき、未来の電力需要を予測するAIモデルを構築することを目的とする。v2.0では、**ブラウザベースのWebインターフェース**を提供し、技術者・非技術者を問わず直感的な操作を可能にする。

### 1.2. プロジェクトスコープ
- **対象データ**: 東京電力電力需要実績データ（2016-2025年）、気象庁気温データ
- **予測対象**: 指定期間の電力需要量（kW単位）
- **開発モデル**: 4種類の機械学習モデル（Keras、LightGBM、PyCaret、RandomForest）
- **出力成果物**: 学習済みモデル、予測結果、可視化グラフ、性能評価レポート
- **新機能（v2.0）**: HTTPサーバー（server.py）、Webダッシュボード（dashboard/index.html）

### 1.3. 成功指標
- **予測精度**: RMSE < 200kW、R2スコア > 0.9
- **処理性能**: メモリ使用量50%削減、学習時間30%短縮
- **システム品質**: コードカバレッジ90%以上、エラー率0.1%以下
- **運用効率**: 自動化率95%以上、デプロイ時間5分以内
- **操作性向上（v2.0）**: 操作時間50%削減、学習コスト30%削減

## 2. ステークホルダー/体制

### 2.1. 技術スタック

#### 2.1.1. 開発環境
| カテゴリ | 技術 | バージョン | 用途 |
|---------|------|------------|------|
| **言語** | Python | 3.10.11 | システム全体開発 |
| **開発環境** | VS Code | 最新版 | IDE、デバッグ、Git管理 |
| **パッケージ管理** | pip | 最新版 | 依存関係管理 |
| **Webサーバー（v2.0）** | http.server | 標準ライブラリ | HTTPサーバー実装 |

#### 2.1.2. データ処理・機械学習
| カテゴリ | ライブラリ | バージョン | 用途 |
|---------|------------|------------|------|
| **データ処理** | Pandas | 1.5.3 | データ読み込み、前処理 |
| **数値計算** | NumPy | 1.24.4 | 配列操作、数値演算 |
| **機械学習基盤** | Scikit-learn | 1.2.2 | データ前処理、評価指標 |
| **深層学習** | TensorFlow/Keras | 2.15.0 | ニューラルネットワーク |
| **勾配ブースティング** | LightGBM | 3.3.5 | 高速機械学習 |
| **自動機械学習** | PyCaret | 3.0.0 | 自動モデル選択・最適化 |
| **可視化** | Matplotlib | 3.7.5 | グラフ描画、結果可視化 |

#### 2.1.3. ファイル管理・保存
| カテゴリ | 技術 | 用途 |
|---------|------|------|
| **モデル保存** | Pickle | 軽量モデル（RandomForest、LightGBM）|
| **深層学習モデル** | HDF5 | Kerasモデル保存 |
| **データ保存** | CSV | 結果データ、中間データ |
| **画像保存** | PNG | 可視化グラフ |
| **ログ保存（v2.0）** | テキストファイル | server.log |

### 2.2. プロジェクト体制・役割分担

#### 2.2.1. プロジェクト体制
| 役割 | 責任範囲 | スキル要件 |
|------|----------|-----------|
| **プロジェクトマネージャー** | 全体統括、進捗管理 | PMP、アジャイル |
| **データサイエンティスト** | モデル開発、精度向上 | Python、機械学習 |
| **システムエンジニア** | インフラ、デプロイ | Docker、クラウド |
| **品質保証エンジニア** | テスト、品質管理 | テスト自動化 |
| **UI/UXデザイナー（v2.0）** | ダッシュボード設計 | HTML/CSS/JavaScript |

#### 2.2.2. 開発プロセス
- **開発手法**: アジャイル（2週間スプリント）
- **バージョン管理**: Git（GitHub Flow）
- **CI/CD**: GitHub Actions
- **ドキュメント**: Markdown、Sphinx

## 3. スコープ

### 3.1. 対象・成果物
- **対象**: AIモデルの設計、実装、学習、評価、および**Webインターフェース統合**
- **成果物**: 学習済みAIモデル、Webダッシュボード、HTTPサーバー、プロジェクトドキュメント群

### 3.2. ページ構成・詳細

#### 3.2.1. v2.0新規追加コンポーネント

##### 3.2.1.1. HTTPサーバーモジュール（server.py）
```python
# サーバー実装概要
PORT = int(os.environ.get('AI_SERVER_PORT', '8002'))

# APIエンドポイント
POST /run-data              # データ処理実行
POST /run-train             # モデル学習実行
POST /run-tomorrow-data     # 最新データ取得
POST /run-tomorrow          # 予測実行
GET  /available-years       # 利用可能年一覧
GET  /                      # ダッシュボード表示

# 実装特徴
- ThreadingTCPServer（並行接続対応）
- subprocess経由でPythonスクリプト実行
- 環境変数AI_TARGET_YEARSによる年指定対応
- 自動ログ記録（server.log）
- タイムアウト設定（40分）
```

##### 3.2.1.2. Webダッシュボード（dashboard/index.html）
```text
UI構成（4カードレイアウト）
┌─────────────────────────────────────┐
│ 電力需要AI予測ダッシュボード           │
├───────┬───────┬───────┬──────────────┤
│モデル │ 予測  │ 学習  │ 学習年       │
│選択   │カード │カード │カード        │
├───────┴───────┴───────┴──────────────┤
│ 予測グラフエリア  │ 学習グラフエリア│
└────────────────────┴─────────────────┘

主要機能:
- 4モデル選択ボタン（Keras/LightGBM/PyCaret/RandomForest）
- ワンクリック実行（データ処理・学習・予測）
- リアルタイムグラフ表示（16:9アスペクト比）
- 指標表示（RMSE/R2/MAE）
- ツールチップ・モーダル機能
- ネオン発光エフェクト
```

#### 3.2.2. 統一アーキテクチャ設計（v1.0からの継承）

##### 3.2.2.1. @dataclass設定クラス統一実装
```python
@dataclass
class ModelConfig:
    """モデル設定統一管理クラス"""
    # ファイルパス設定
    INPUT_X: str = r"..\..\data\Xtrain.csv"
    INPUT_Y: str = r"..\..\data\Ytrain.csv"
    MODEL_SAV: str = r"{model}_model.sav"
    OUTPUT_CSV: str = r"{model}_Ypred.csv"
    OUTPUT_PNG: str = r"{model}_Ypred.png"
    
    # データ処理設定
    DATA_DTYPE: str = 'float32'          # メモリ最適化
    ENCODING: str = 'shift_jis'          # 日本語データ対応
    RANDOM_STATE: int = 42               # 再現性確保
    
    # 機械学習設定
    TEST_SIZE: float = 0.1               # テストデータ比率
    CV_FOLDS: int = 5                    # クロスバリデーション
    N_JOBS: int = -1                     # 並列処理最大活用
    
    # 可視化設定
    FIGURE_SIZE: tuple = (16, 9)         # 16:9アスペクト比統一
    DPI: int = 100                       # 解像度統一
    JAPANESE_FONTS: list = field(default_factory=lambda: [
        'Yu Gothic', 'Meiryo', 'MS Gothic', 'DejaVu Sans'
    ])
    
    # 性能最適化設定
    MEMORY_OPTIMIZATION: bool = True      # メモリ最適化有効
    GARBAGE_COLLECTION: bool = True       # ガベージコレクション有効
```

##### 3.2.2.2. robust_model_operation デコレータ実装
```python
def robust_model_operation(operation_name: str):
    """統一モデル操作デコレータ - エラーハンドリングと性能監視"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # 実行時間・メモリ使用量測定開始
            start_time = time.time()
            initial_memory = psutil.Process().memory_info().rss / 1024 / 1024
            
            try:
                print(f"=== {operation_name} 開始 ===")
                result = func(*args, **kwargs)
                
                # パフォーマンス測定
                execution_time = time.time() - start_time
                final_memory = psutil.Process().memory_info().rss / 1024 / 1024
                memory_diff = final_memory - initial_memory
                
                print(f"=== {operation_name} 完了 ===")
                print(f"実行時間: {execution_time:.3f}秒")
                print(f"メモリ使用量: {initial_memory:.1f}MB → {final_memory:.1f}MB")
                print(f"メモリ差分: {memory_diff:+.1f}MB")
                
                # ガベージコレクション実行
                collected = gc.collect()
                print(f"ガベージコレクション: {collected}個のオブジェクトを回収")
                
                return result
                
            except Exception as e:
                elapsed_time = time.time() - start_time
                print(f"=== {operation_name} エラー (実行時間: {elapsed_time:.2f}秒) ===")
                print(f"エラー詳細: {str(e)}")
                traceback.print_exc()
                raise Exception(f"{operation_name}でエラーが発生: {e}") from e
                
        return wrapper
    return decorator
```

#### 3.2.3. モジュール別詳細設計（v1.0からの継承）

##### 3.2.3.1. 基盤データ処理モジュール (data/data.py)
**目的**: 電力需要・気温データの統合処理エンジン
**実装特徴**:
- SHIFT-JISエンコーディング対応
- スキップ行設定（電力需要:3行、気温:5行）
- float32型変換によるメモリ50%削減
- 特徴量エンジニアリング（MONTH、WEEK、HOUR、TEMP）
- **v2.0拡張**: 環境変数AI_TARGET_YEARSによる年フィルタリング対応

```python
@dataclass
class DataConfig:
    JUYO_PATTERN: str = r"data\juyo-*.csv"
    TEMP_PATTERN: str = r"data\temperature-*.csv"
    OUTPUT_X: str = r"data\X.csv"
    OUTPUT_Y: str = r"data\Y.csv"
    ENCODING: str = 'shift_jis'
    JUYO_SKIPROWS: int = 3
    TEMP_SKIPROWS: int = 5
    DATA_DTYPE: str = 'float32'
    X_COLS: tuple = ("MONTH", "WEEK", "HOUR", "TEMP")
    Y_COLS: tuple = ("KW",)
```

##### 3.2.3.2. 学習モジュール群 (train/)

**A. Keras深層学習モジュール (train/Keras/Keras_train.py)**
**B. LightGBM勾配ブースティングモジュール (train/LightGBM/LightGBM_train.py)**
**C. PyCaret自動機械学習モジュール (train/Pycaret/Pycaret_train.py)**
**D. RandomForestアンサンブルモジュール (train/RandomForest/RandomForest_train.py)**

**v2.0拡張ポイント**:
- 環境変数AI_TARGET_YEARSによる学習年指定対応
- コマンドライン引数による年指定対応
- HTTPサーバー経由での実行対応

##### 3.2.3.3. 予測モジュール群 (tomorrow/)

**A. 最新データ取得モジュール (tomorrow/data.py)**
**B. 気温データ処理モジュール (tomorrow/temp.py)**
**C. 各モデル予測実行モジュール**

**v2.0での変更**: 実装内容はv1.0と完全同一（透過的実行）

#### 3.2.4. 可視化統一仕様（v1.0からの継承）

##### 3.2.4.1. matplotlib設定統一
```python
# 16:9アスペクト比統一設定
plt.rcParams['figure.figsize'] = (16, 9)
plt.rcParams['figure.dpi'] = 100
plt.rcParams['savefig.dpi'] = 100
plt.rcParams['savefig.bbox'] = 'tight'
plt.rcParams['savefig.pad_inches'] = 0.1

# フォント・グリッド設定
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['font.size'] = 10
plt.rcParams['axes.grid'] = True
plt.rcParams['grid.alpha'] = 0.3
plt.rcParams['lines.linewidth'] = 1.5
plt.rcParams['axes.linewidth'] = 0.8
```

## 4. マイルストーン・スケジュール

### 4.1. システムアーキテクチャ・データフロー

#### 4.1.1. システムアーキテクチャ（v2.0）
```text
AI_v2/
├── data/                          # データ層（v1.0と同一）
│   ├── data.py                    # 基盤データ処理エンジン
│   ├── juyo-*.csv                 # 電力需要実績データ
│   ├── temperature-*.csv          # 気温データ
│   ├── X.csv / Y.csv              # 統合データ
│   ├── Xtrain.csv / Ytrain.csv    # 学習用データセット
│   └── Xtest.csv / Ytest.csv      # テスト用データセット
├── train/                         # モデル学習層（v1.0と同一）
│   ├── Keras/
│   ├── LightGBM/
│   ├── Pycaret/
│   └── RandomForest/
├── tomorrow/                      # 予測実行層（v1.0と同一）
│   ├── data.py / temp.py
│   ├── tomorrow.csv / Ytest.csv
│   ├── Keras/
│   ├── LightGBM/
│   ├── Pycaret/
│   └── RandomForest/
├── requirements.txt               # 依存関係（v1.0と同一）
├── server.py                      # ★v2.0新規：HTTPサーバー（250行）
├── server.log                     # ★v2.0新規：自動生成ログ
└── dashboard/                     # ★v2.0新規：Webインターフェース
    └── index.html                 # ダッシュボードUI（1117行）
```

#### 4.1.2. v2.0実行フロー（Web UI）

```text
ユーザー（技術者+非技術者）
    ↓
1. サーバー起動（1回のみ）
   py -3.10 server.py
    ↓
2. ブラウザ自動起動
   http://localhost:8002/
    ↓
3. Webダッシュボード表示
    ↓
4. モデル選択（ボタンクリック）
   [LightGBM選択]
    ↓
5. 学習年選択（ボタンクリック）
   [2022][2023][2024]
    ↓
6. データ処理実行
   [データ処理]ボタン → subprocess: data.py実行
    ↓
7. 学習実行
   [学習]ボタン → subprocess: LightGBM_train.py実行
   実行中: 緑ネオン発光
    ↓
8. 結果表示
   RMSE/R2/MAE自動表示、グラフ表示（16:9）
    ↓
9. 予測実行
   [最新データ取得]ボタン → subprocess: data.py + temp.py実行
   [予測]ボタン → subprocess: LightGBM_tomorrow.py実行
    ↓
10. 結果表示・ダウンロード
    予測グラフ表示、拡大機能、ダウンロード機能
```

**v1.0との比較**: v1.0はPowerShellコマンド個別実行。v2.0はブラウザ操作のみで完結。

### 4.2. デザイン仕様

#### 4.2.1. 可視化デザイン標準（v1.0からの継承）
- **図サイズ**: 16:9アスペクト比 (figsize=(16, 9))
- **DPI設定**: 100DPI（高品質出力）
- **フォント**: DejaVu Sans（日本語対応）
- **フォントサイズ**: タイトル12pt、軸ラベル12pt、凡例11pt、目盛り10pt
- **グリッド**: 半透明グリッド (alpha=0.3)
- **線幅**: メイン1.5pt、軸0.8pt
- **余白**: tight_layout()自動調整

#### 4.2.2. Webダッシュボードデザイン（v2.0新規）
- **テーマ**: ダークモード（グラデーション背景）
- **カラーパレット**: 
  - 予測値: #1f77b4 (青系)
  - 実績値: #ff7f0e (オレンジ系)
  - ボタン: 緑ネオン発光（選択時）、反転表示（未選択時）
- **レスポンシブ**: 1200px以上推奨
- **ブラウザ要件**: Chrome/Firefox/Edge最新版

#### 4.2.3. ファイル命名規則（v1.0からの継承）
- **モデル**: `{ModelName}_model.{ext}`
- **予測結果**: `{ModelName}_Ypred.csv`
- **可視化**: `{ModelName}_Ypred.png`, `{ModelName}_Ypred_7d.png`
- **tomorrow予測**: `{ModelName}_tomorrow.csv/png`

### 4.3. 開発スケジュール

#### 4.3.1. フェーズ別スケジュール（v2.0反映）
| フェーズ | 期間 | 主要タスク | 成果物 |
|---------|------|-----------|--------|
| **Phase 1: 基盤構築** | Week 1-2 | データ処理基盤、開発環境整備 | data.py, 開発ガイドライン |
| **Phase 2: モデル開発** | Week 3-6 | 4種類のモデル実装・最適化 | 学習スクリプト、モデルファイル |
| **Phase 3: 予測システム** | Week 7-8 | 予測システム構築、API化 | 予測スクリプト、結果可視化 |
| **Phase 4: Webインターフェース** | Week 9-10 | HTTPサーバー・ダッシュボード実装 | server.py, dashboard/index.html |
| **Phase 5: 統合テスト・運用準備** | Week 11-12 | ドキュメント整備、デプロイ準備 | 運用ドキュメント、リリース版 |

#### 4.3.2. マイルストーン（v2.0反映）
- **M1 (Week 2)**: データ処理基盤完成
- **M2 (Week 4)**: Keras+LightGBMモデル完成
- **M3 (Week 6)**: 全モデル完成・性能評価
- **M4 (Week 8)**: 予測システム統合完成
- **M5 (Week 10)**: Webダッシュボード完成・統合テスト完了
- **M6 (Week 12)**: プロダクション環境リリース

## 5. 予算・リソース計画

### 5.1. 品質保証・成功指標

#### 5.1.1. 技術的成功指標
| カテゴリ | 指標 | 目標値 | 測定方法 |
|---------|------|--------|---------|
| **予測精度** | RMSE | < 200kW | テストデータ評価 |
| **予測精度** | R2スコア | > 0.9 | テストデータ評価 |
| **メモリ効率** | 使用量削減 | 50%削減 | float32最適化効果 |
| **処理速度** | 学習時間短縮 | 30%短縮 | 並列処理効果 |
| **システム安定性** | エラー率 | < 0.1% | 運用時監視 |
| **操作性（v2.0）** | 操作時間削減 | 50%削減 | CLI→WebUI効果 |
| **学習コスト（v2.0）** | 習得時間削減 | 75%削減 | UI改善効果 |

#### 5.1.2. 品質保証プロセス
1. **コード品質**
   - PEP 8準拠チェック
   - 型ヒント完全実装
   - docstring完備

2. **テスト戦略**
   - 単体テスト: 各モジュール90%カバレッジ
   - 統合テスト: エンドツーエンド検証
   - 性能テスト: 大量データ処理検証
   - **UI/UXテスト（v2.0）**: ブラウザ互換性、レスポンシブテスト

3. **レビュープロセス**
   - コードレビュー必須
   - アーキテクチャレビュー
   - セキュリティレビュー
   - **UI/UXレビュー（v2.0）**: 操作性・視認性評価

## 6. リスク/課題管理

### 6.1. v2.0での機能改善

#### 6.1.1. 運用効率化
- **CLI実行（v1.0）**: コマンド入力30秒 → **WebUI（v2.0）**: ボタンクリック1秒（97%削減）
- **結果確認（v1.0）**: ファイル確認60秒 → **WebUI（v2.0）**: 自動表示5秒（92%削減）
- **モデル切替（v1.0）**: コマンド再入力30秒 → **WebUI（v2.0）**: ボタンクリック2秒（93%削減）
- **操作学習時間（v1.0）**: 2時間 → **WebUI（v2.0）**: 30分（75%削減）

#### 6.1.2. エラー対処の改善
- **v1.0**: コンソール出力確認（技術知識必要）
- **v2.0**: Webダッシュボードにエラーメッセージ表示 + server.logで詳細確認

#### 6.1.3. ログ管理
- **v1.0**: 標準出力のみ（実行履歴追跡困難）
- **v2.0**: server.log自動生成（全実行履歴記録、タイムスタンプ付き）

### 6.2. リスク管理

#### 6.2.1. 技術リスク
| リスク項目 | 発生確率 | 影響度 | 対策 |
|-----------|----------|--------|--------|
| **ライブラリ互換性問題** | 高 | 中 | バージョン固定、仮想環境使用 |
| **モデル性能劣化** | 中 | 高 | 定期評価、閾値監視 |
| **メモリ不足** | 中 | 中 | float32最適化、バッチサイズ調整 |
| **データ品質問題** | 中 | 高 | データ検証、異常値検出 |
| **ブラウザ互換性（v2.0）** | 低 | 中 | 主要ブラウザ対応確認 |
| **ポート競合（v2.0）** | 低 | 低 | 環境変数AI_SERVER_PORTで変更可能 |

#### 6.2.2. 運用リスク
| リスク項目 | 発生確率 | 影響度 | 対策 |
|-----------|----------|--------|--------|
| **API制限・障害** | 中 | 中 | リトライ機能、フォールバック |
| **ストレージ容量不足** | 低 | 中 | 監視アラート、自動クリーンアップ |
| **担当者不在** | 中 | 高 | ドキュメント整備、複数人対応 |
| **サーバー停止（v2.0）** | 低 | 低 | 自動再起動スクリプト |

## 7. 品質計画

### 7.1. 保守・運用計画

#### 7.1.1. 定期保守
- **週次**: 予測精度監視、エラーログ確認、**server.log確認（v2.0）**
- **月次**: モデル性能評価、データ品質検証
- **四半期**: システム最適化、セキュリティ更新、**ブラウザ互換性確認（v2.0）**

#### 7.1.2. 監視項目
- **技術監視**: CPU使用率、メモリ使用量、ディスク容量、**HTTPサーバー稼働状態（v2.0）**
- **業務監視**: 予測精度、データ更新状況、API応答時間、**Web UI応答時間（v2.0）**
- **品質監視**: エラー発生率、処理成功率、**ブラウザエラー率（v2.0）**

#### 7.1.3. エスカレーション
1. **Level 1**: 自動復旧・警告ログ
2. **Level 2**: 運用担当者アラート（**server.log確認**）
3. **Level 3**: 開発チーム緊急対応
4. **Level 4**: ベンダー・外部専門家

## 8. コミュニケーション計画

### 8.1. v2.0での改善ポイント

#### 8.1.1. 操作性の劇的改善
| 操作 | v1.0（CLI） | v2.0（Web UI） | 改善率 |
|------|-------------|----------------|--------|
| モデル選択 | コマンド入力30秒 | ボタンクリック1秒 | 97%削減 |
| 学習実行 | コマンド確認20秒 | ボタンクリック3秒 | 85%削減 |
| 結果確認 | ファイル確認60秒 | 自動表示5秒 | 92%削減 |
| モデル切替 | コマンド再入力30秒 | ボタンクリック2秒 | 93%削減 |

#### 8.1.2. リソース使用量（v2.0追加分）
| 項目 | v1.0 | v2.0 | 差異 |
|------|------|------|------|
| メモリ | 約2GB | 約2.05GB | +50MB（2.5%増、無視可能） |
| CPU | 処理時のみ | 処理時+5%（サーバー） | 影響微小 |
| ディスク | 基本ファイルのみ | +2MB（server.py, index.html, server.log） | 無視可能 |

### 8.2. 進捗管理・モニタリング

#### 8.2.1. 進捗トラッキング指標
| 指標 | 測定頻度 | 目標値 | アクション |
|------|----------|--------|-----------|
| **タスク完了率** | 毎日 | >90% | 遅延タスクの優先度見直し |
| **コード品質** | 毎週 | >8.0/10 | コードレビュー強化 |
| **テストカバレッジ** | 毎週 | >90% | テスト追加実装 |
| **性能目標達成度** | 毎月 | >95% | アルゴリズム見直し |
| **UI/UX評価（v2.0）** | 毎週 | >4.0/5.0 | UI改善 |

#### 8.2.2. リスク管理
| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| **データ品質問題** | 高 | 中 | データ検証強化、バックアップ |
| **モデル精度不足** | 高 | 低 | アルゴリズム多様化、パラメータ調整 |
| **性能要件未達** | 中 | 中 | 早期プロトタイプ、最適化 |
| **スケジュール遅延** | 中 | 中 | バッファ確保、並行開発 |
| **UIバグ（v2.0）** | 中 | 低 | ブラウザテスト自動化 |

## 9. 変更管理・構成管理

### 9.1. v2.0での変更内容

#### 9.1.1. 新規追加ファイル
- `server.py`: HTTPサーバー実装（約250行）
- `dashboard/index.html`: Webダッシュボード（約1117行）
- `server.log`: 自動生成ログファイル

#### 9.1.2. 既存ファイルの変更
- `data/data.py`: 環境変数AI_TARGET_YEARS対応
- `train/*/train.py`: 環境変数・コマンドライン引数対応
- `tomorrow/*/tomorrow.py`: 変更なし（v1.0と完全同一）

#### 9.1.3. 依存関係の変更
- **追加ライブラリ**: なし（Python標準ライブラリのみ使用）
- **requirements.txt**: v1.0と完全同一（28パッケージ）

## 10. 依存関係・前提条件・制約

### 10.1. プロジェクト成功の定義

#### 10.1.1. 技術的成功
- 4種類のモデルが全て目標精度を達成
- メモリ効率50%向上、処理速度30%向上を実現
- エラー率0.1%以下の安定システムを構築
- 16:9統一可視化による高品質出力を実現
- **Webダッシュボードによる操作性50%向上（v2.0）**

#### 10.1.2. ビジネス的成功
- 電力需要予測精度の大幅向上を実現
- 運用コスト削減に貢献（**v2.0: 50%削減**）
- 将来の拡張性・保守性を確保
- ステークホルダー満足度90%以上
- **非技術者でも操作可能（v2.0）**

#### 10.1.3. 持続可能性
- 完全なドキュメント化による知識の継承
- 自動化による運用負荷軽減（**v2.0: WebUI自動化**）
- 拡張可能なアーキテクチャによる将来対応
- セキュリティ・コンプライアンス要件の完全遵守
- **段階的移行可能（v1.0とv2.0の並行利用可能）**

本AIモデルの構築と実行には、`AI/requirements.txt`に記載された多数の専門的なPythonライブラリが必要である。これには、機械学習、時系列分析、データ処理のためのライブラリが含まれる。

- **機械学習フレームワーク**: `tensorflow`, `keras`, `scikit-learn`, `lightgbm`, `pycaret`
- **時系列分析**: `statsmodels`, `pmdarima`, `sktime`, `tbats`
- **データ処理・数値計算**: `pandas`, `numpy`, `scipy`
- **可視化**: `matplotlib`, `plotly`
- **Webサーバー（v2.0）**: Python標準ライブラリ `http.server`, `subprocess`, `threading`

```txt
# AI/requirements.txt の一部（v1.0と同一）
numpy==1.24.4
pandas==1.5.3
scikit-learn==1.2.2
lightgbm==3.3.5
pycaret==3.0.0
tensorflow==2.15.0
keras==2.15.0
statsmodels==0.14.5
sktime==0.26.0
# ... その他多数
```

---
